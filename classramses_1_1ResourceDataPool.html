<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RAMSES Documentation: ramses::ResourceDataPool Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ramses_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RAMSES Documentation
   &#160;<span id="projectnumber">27.0.101</span>
   </div>
   <div id="projectbrief">Information for RAMSES users and developers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceramses.html">ramses</a></li><li class="navelem"><a class="el" href="classramses_1_1ResourceDataPool.html">ResourceDataPool</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classramses_1_1ResourceDataPool-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ramses::ResourceDataPool Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classramses_1_1ResourceDataPool.html" title="The ResourceDataPool holds resource data which can be instantiated for a given scene....">ResourceDataPool</a> holds resource data which can be instantiated for a given scene. <a class="el" href="classramses_1_1Resource.html" title="The Resource is the base class of all resources, such as arrays and textures.">Resource</a> data can either be added by calling the add functions or by attaching a resource data file to the pool. The same resource data can be instantiated by multiple scenes at the same time.  
 <a href="classramses_1_1ResourceDataPool.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ResourceDataPool_8h_source.html">ResourceDataPool.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae215577b0f5e9d89ca29339d42b1c399"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structramses_1_1resourceId__t.html">resourceId_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1ResourceDataPool.html#ae215577b0f5e9d89ca29339d42b1c399">addArrayResourceData</a> (<a class="el" href="namespaceramses.html#a6de13d29afe1f37ca41caec5ae20532c">EDataType</a> type, uint32_t numElements, const void *arrayData, <a class="el" href="namespaceramses.html#ad235ad0adbf1a441d1339ab3a09159ac">resourceCacheFlag_t</a> cacheFlag=<a class="el" href="namespaceramses.html#aa4f32a02a4d27b0759cf54915b6ce602">ResourceCacheFlag_DoNotCache</a>, const char *name=nullptr)</td></tr>
<tr class="memdesc:ae215577b0f5e9d89ca29339d42b1c399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add <a class="el" href="classramses_1_1ArrayResource.html" title="The ArrayResource stores a data array of a given type. The data is immutable. The resource can be use...">ArrayResource</a> data to the pool. The pool is taking ownership of the given range of data of a certain type and keeps it to instantiate resource from it later via createResourceForScene. See <a class="el" href="classramses_1_1ArrayResource.html" title="The ArrayResource stores a data array of a given type. The data is immutable. The resource can be use...">ramses::ArrayResource</a> for more details. Readding the same resource data again will return the previous resource id, but not recreate the resource data. Readding a same resource requires removing it again with removeResourceData.  <a href="classramses_1_1ResourceDataPool.html#ae215577b0f5e9d89ca29339d42b1c399">More...</a><br /></td></tr>
<tr class="separator:ae215577b0f5e9d89ca29339d42b1c399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453216272b4e0045f9b875809b7fc7c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structramses_1_1resourceId__t.html">resourceId_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1ResourceDataPool.html#a453216272b4e0045f9b875809b7fc7c2">addTexture2DData</a> (<a class="el" href="namespaceramses.html#a19ee2a3bbf78fdc5ad2d41ffa6d766ed">ETextureFormat</a> format, uint32_t width, uint32_t height, uint32_t mipMapCount, const <a class="el" href="structramses_1_1MipLevelData.html">MipLevelData</a> mipLevelData[], bool generateMipChain=false, const <a class="el" href="structramses_1_1TextureSwizzle.html">TextureSwizzle</a> &amp;swizzle={}, <a class="el" href="namespaceramses.html#ad235ad0adbf1a441d1339ab3a09159ac">resourceCacheFlag_t</a> cacheFlag=<a class="el" href="namespaceramses.html#aa4f32a02a4d27b0759cf54915b6ce602">ResourceCacheFlag_DoNotCache</a>, const char *name=nullptr)</td></tr>
<tr class="memdesc:a453216272b4e0045f9b875809b7fc7c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add <a class="el" href="classramses_1_1Texture2D.html" title="Texture represents a 2-D texture resource.">Texture2D</a> data to the pool. It is taking ownership of the given range of texture data in the specified pixel format and keeps it to instantiate resource from it later via createResourceForScene. See <a class="el" href="classramses_1_1Texture2D.html" title="Texture represents a 2-D texture resource.">ramses::Texture2D</a> for more details.  <a href="classramses_1_1ResourceDataPool.html#a453216272b4e0045f9b875809b7fc7c2">More...</a><br /></td></tr>
<tr class="separator:a453216272b4e0045f9b875809b7fc7c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88a1a98ff49acd37893b49c4d08d706"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structramses_1_1resourceId__t.html">resourceId_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1ResourceDataPool.html#ac88a1a98ff49acd37893b49c4d08d706">addTexture3DData</a> (<a class="el" href="namespaceramses.html#a19ee2a3bbf78fdc5ad2d41ffa6d766ed">ETextureFormat</a> format, uint32_t width, uint32_t height, uint32_t depth, uint32_t mipMapCount, const <a class="el" href="structramses_1_1MipLevelData.html">MipLevelData</a> mipLevelData[], bool generateMipChain=false, <a class="el" href="namespaceramses.html#ad235ad0adbf1a441d1339ab3a09159ac">resourceCacheFlag_t</a> cacheFlag=<a class="el" href="namespaceramses.html#aa4f32a02a4d27b0759cf54915b6ce602">ResourceCacheFlag_DoNotCache</a>, const char *name=nullptr)</td></tr>
<tr class="memdesc:ac88a1a98ff49acd37893b49c4d08d706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add <a class="el" href="classramses_1_1Texture3D.html" title="Texture represents a texture resource.">Texture3D</a> data to the pool. It is taking ownership of the given range of texture data in the specified pixel format and keeps it to instantiate resource from it later via createResourceForScene. See <a class="el" href="classramses_1_1Texture3D.html" title="Texture represents a texture resource.">ramses::Texture3D</a> for more details. Readding the same resource data again will return the previous resource id, but not recreate the resource data. Readding a same resource requires removing it again with removeResourceData.  <a href="classramses_1_1ResourceDataPool.html#ac88a1a98ff49acd37893b49c4d08d706">More...</a><br /></td></tr>
<tr class="separator:ac88a1a98ff49acd37893b49c4d08d706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98cb48abafaa5e63e740d0c8c43c51d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structramses_1_1resourceId__t.html">resourceId_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1ResourceDataPool.html#ab98cb48abafaa5e63e740d0c8c43c51d">addTextureCubeData</a> (<a class="el" href="namespaceramses.html#a19ee2a3bbf78fdc5ad2d41ffa6d766ed">ETextureFormat</a> format, uint32_t size, uint32_t mipMapCount, const <a class="el" href="structramses_1_1CubeMipLevelData.html">CubeMipLevelData</a> mipLevelData[], bool generateMipChain=false, const <a class="el" href="structramses_1_1TextureSwizzle.html">TextureSwizzle</a> &amp;swizzle={}, <a class="el" href="namespaceramses.html#ad235ad0adbf1a441d1339ab3a09159ac">resourceCacheFlag_t</a> cacheFlag=<a class="el" href="namespaceramses.html#aa4f32a02a4d27b0759cf54915b6ce602">ResourceCacheFlag_DoNotCache</a>, const char *name=nullptr)</td></tr>
<tr class="memdesc:ab98cb48abafaa5e63e740d0c8c43c51d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add Cube Texture data to the pool. It is taking ownership of the given range of texture data in the specified pixel format and keeps it to instantiate resource from it later via createResourceForScene. All texel values are initially initialized to 0. See <a class="el" href="classramses_1_1TextureCube.html" title="TextureCube stores pixel data with 6 equally sized quadratic faces.">ramses::TextureCube</a> for more details. Readding the same resource data again will return the previous resource id, but not recreate the resource data. Readding a same resource requires removing it again with removeResourceData.  <a href="classramses_1_1ResourceDataPool.html#ab98cb48abafaa5e63e740d0c8c43c51d">More...</a><br /></td></tr>
<tr class="separator:ab98cb48abafaa5e63e740d0c8c43c51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada23fe94a081008205b0799300a30c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structramses_1_1resourceId__t.html">resourceId_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1ResourceDataPool.html#aada23fe94a081008205b0799300a30c8">addEffectData</a> (const <a class="el" href="classramses_1_1EffectDescription.html">EffectDescription</a> &amp;effectDesc, <a class="el" href="namespaceramses.html#ad235ad0adbf1a441d1339ab3a09159ac">resourceCacheFlag_t</a> cacheFlag=<a class="el" href="namespaceramses.html#aa4f32a02a4d27b0759cf54915b6ce602">ResourceCacheFlag_DoNotCache</a>, const char *name=nullptr)</td></tr>
<tr class="memdesc:aada23fe94a081008205b0799300a30c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add <a class="el" href="classramses_1_1Effect.html" title="An effect describes how an object will be rendered to the screen.">Effect</a> data to the pool by parsing a GLSL shader described by an <a class="el" href="classramses_1_1EffectDescription.html" title="An effect description holds all necessary information for an effect to be created.">EffectDescription</a> instance. The data can be used to instantiate a resource via createResourceForScene. Refer to RamsesClient::getLastEffectErrorMessages in case of parsing error. See <a class="el" href="classramses_1_1Effect.html" title="An effect describes how an object will be rendered to the screen.">ramses::Effect</a> for more details. Readding the same resource data again will return the previous resource id, but not recreate the resource data. Readding a same resource requires removing it again with removeResourceData.  <a href="classramses_1_1ResourceDataPool.html#aada23fe94a081008205b0799300a30c8">More...</a><br /></td></tr>
<tr class="separator:aada23fe94a081008205b0799300a30c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ece31cb38b75149375fbf15d3dbf7a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1ResourceDataPool.html#a37ece31cb38b75149375fbf15d3dbf7a">getLastEffectErrorMessages</a> () const</td></tr>
<tr class="memdesc:a37ece31cb38b75149375fbf15d3dbf7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the GLSL error messages that were produced at the creation of the last <a class="el" href="classramses_1_1Effect.html" title="An effect describes how an object will be rendered to the screen.">Effect</a> data.  <a href="classramses_1_1ResourceDataPool.html#a37ece31cb38b75149375fbf15d3dbf7a">More...</a><br /></td></tr>
<tr class="separator:a37ece31cb38b75149375fbf15d3dbf7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0540e5cf6761651dcf5ff8766bdc2ae5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1ResourceDataPool.html#a0540e5cf6761651dcf5ff8766bdc2ae5">removeResourceData</a> (<a class="el" href="structramses_1_1resourceId__t.html">resourceId_t</a> const &amp;id)</td></tr>
<tr class="memdesc:a0540e5cf6761651dcf5ff8766bdc2ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes data which was added to the pool. The provided resource id might not be used anymore to instantiate a resource via createResourceForScene, depending on how many times corresponding addResourceData was called before. Already instantiated resources will not be affected by removeResourceData.  <a href="classramses_1_1ResourceDataPool.html#a0540e5cf6761651dcf5ff8766bdc2ae5">More...</a><br /></td></tr>
<tr class="separator:a0540e5cf6761651dcf5ff8766bdc2ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f25555c4706026777d9abc4c8937082"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1ResourceDataPool.html#a2f25555c4706026777d9abc4c8937082">addResourceDataFile</a> (std::string const &amp;filename)</td></tr>
<tr class="memdesc:a2f25555c4706026777d9abc4c8937082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a file to the resource data pool, so the contained data can be instantiated via createResourceForScene.  <a href="classramses_1_1ResourceDataPool.html#a2f25555c4706026777d9abc4c8937082">More...</a><br /></td></tr>
<tr class="separator:a2f25555c4706026777d9abc4c8937082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9f511265452e08eb0819e912f2237b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1ResourceDataPool.html#ace9f511265452e08eb0819e912f2237b">forceLoadResourcesFromResourceDataFile</a> (std::string const &amp;filename)</td></tr>
<tr class="memdesc:ace9f511265452e08eb0819e912f2237b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads all resources in a file currently in use by any scene from that file to memory.  <a href="classramses_1_1ResourceDataPool.html#ace9f511265452e08eb0819e912f2237b">More...</a><br /></td></tr>
<tr class="separator:ace9f511265452e08eb0819e912f2237b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f33d0b19ec2c60deac05d95b801e71"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1ResourceDataPool.html#ac0f33d0b19ec2c60deac05d95b801e71">removeResourceDataFile</a> (std::string const &amp;filename)</td></tr>
<tr class="memdesc:ac0f33d0b19ec2c60deac05d95b801e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a resource file from the pool. The contained data can then not be used anymore to instantiate a resource via createResourceForScene.  <a href="classramses_1_1ResourceDataPool.html#ac0f33d0b19ec2c60deac05d95b801e71">More...</a><br /></td></tr>
<tr class="separator:ac0f33d0b19ec2c60deac05d95b801e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66fa9df892c8dc8e9dc47693910936e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classramses_1_1Resource.html">Resource</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1ResourceDataPool.html#a66fa9df892c8dc8e9dc47693910936e2">createResourceForScene</a> (<a class="el" href="classramses_1_1Scene.html">Scene</a> &amp;scene, <a class="el" href="structramses_1_1resourceId__t.html">resourceId_t</a> const &amp;id)</td></tr>
<tr class="memdesc:a66fa9df892c8dc8e9dc47693910936e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a resource for a scene out of pool data. The resource can then be used in scene as if created with the scenes create resource functions.  <a href="classramses_1_1ResourceDataPool.html#a66fa9df892c8dc8e9dc47693910936e2">More...</a><br /></td></tr>
<tr class="separator:a66fa9df892c8dc8e9dc47693910936e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ad1a91dfcc151202a8faac2d98a1b83df"><td class="memItemLeft" align="right" valign="top">ResourceDataPoolImpl &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1ResourceDataPool.html#ad1a91dfcc151202a8faac2d98a1b83df">impl</a></td></tr>
<tr class="separator:ad1a91dfcc151202a8faac2d98a1b83df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ac004d8d7200d41ee843cea624fad9731"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1ResourceDataPool.html#ac004d8d7200d41ee843cea624fad9731">RamsesClientImpl</a></td></tr>
<tr class="memdesc:ac004d8d7200d41ee843cea624fad9731"><td class="mdescLeft">&#160;</td><td class="mdescRight">RamsesClientImpl is the factory for creating the <a class="el" href="classramses_1_1ResourceDataPool.html" title="The ResourceDataPool holds resource data which can be instantiated for a given scene....">ResourceDataPool</a> instance.  <a href="classramses_1_1ResourceDataPool.html#ac004d8d7200d41ee843cea624fad9731">More...</a><br /></td></tr>
<tr class="separator:ac004d8d7200d41ee843cea624fad9731"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classramses_1_1ResourceDataPool.html" title="The ResourceDataPool holds resource data which can be instantiated for a given scene....">ResourceDataPool</a> holds resource data which can be instantiated for a given scene. <a class="el" href="classramses_1_1Resource.html" title="The Resource is the base class of all resources, such as arrays and textures.">Resource</a> data can either be added by calling the add functions or by attaching a resource data file to the pool. The same resource data can be instantiated by multiple scenes at the same time. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>This class was being introduced to cover legacy ramses use cases. Using this class is discouraged and it might be removed without warning in the future. </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ae215577b0f5e9d89ca29339d42b1c399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae215577b0f5e9d89ca29339d42b1c399">&#9670;&nbsp;</a></span>addArrayResourceData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structramses_1_1resourceId__t.html">resourceId_t</a> ramses::ResourceDataPool::addArrayResourceData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a6de13d29afe1f37ca41caec5ae20532c">EDataType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>arrayData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ad235ad0adbf1a441d1339ab3a09159ac">resourceCacheFlag_t</a>&#160;</td>
          <td class="paramname"><em>cacheFlag</em> = <code><a class="el" href="namespaceramses.html#aa4f32a02a4d27b0759cf54915b6ce602">ResourceCacheFlag_DoNotCache</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add <a class="el" href="classramses_1_1ArrayResource.html" title="The ArrayResource stores a data array of a given type. The data is immutable. The resource can be use...">ArrayResource</a> data to the pool. The pool is taking ownership of the given range of data of a certain type and keeps it to instantiate resource from it later via createResourceForScene. See <a class="el" href="classramses_1_1ArrayResource.html" title="The ArrayResource stores a data array of a given type. The data is immutable. The resource can be use...">ramses::ArrayResource</a> for more details. Readding the same resource data again will return the previous resource id, but not recreate the resource data. Readding a same resource requires removing it again with removeResourceData. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The data type of the array elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements of the given data type to use for the resource. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrayData</td><td>Pointer to the data to be used to create the array from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cacheFlag</td><td>The optional flag sent to the renderer. The value describes how the cache implementation should handle the resource. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The optional name of the <a class="el" href="classramses_1_1ArrayResource.html" title="The ArrayResource stores a data array of a given type. The data is immutable. The resource can be use...">ArrayResource</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resource id of the created pool <a class="el" href="classramses_1_1ArrayResource.html" title="The ArrayResource stores a data array of a given type. The data is immutable. The resource can be use...">ArrayResource</a> </dd></dl>

</div>
</div>
<a id="aada23fe94a081008205b0799300a30c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada23fe94a081008205b0799300a30c8">&#9670;&nbsp;</a></span>addEffectData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structramses_1_1resourceId__t.html">resourceId_t</a> ramses::ResourceDataPool::addEffectData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classramses_1_1EffectDescription.html">EffectDescription</a> &amp;&#160;</td>
          <td class="paramname"><em>effectDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ad235ad0adbf1a441d1339ab3a09159ac">resourceCacheFlag_t</a>&#160;</td>
          <td class="paramname"><em>cacheFlag</em> = <code><a class="el" href="namespaceramses.html#aa4f32a02a4d27b0759cf54915b6ce602">ResourceCacheFlag_DoNotCache</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add <a class="el" href="classramses_1_1Effect.html" title="An effect describes how an object will be rendered to the screen.">Effect</a> data to the pool by parsing a GLSL shader described by an <a class="el" href="classramses_1_1EffectDescription.html" title="An effect description holds all necessary information for an effect to be created.">EffectDescription</a> instance. The data can be used to instantiate a resource via createResourceForScene. Refer to RamsesClient::getLastEffectErrorMessages in case of parsing error. See <a class="el" href="classramses_1_1Effect.html" title="An effect describes how an object will be rendered to the screen.">ramses::Effect</a> for more details. Readding the same resource data again will return the previous resource id, but not recreate the resource data. Readding a same resource requires removing it again with removeResourceData. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">effectDesc</td><td><a class="el" href="classramses_1_1Effect.html" title="An effect describes how an object will be rendered to the screen.">Effect</a> description. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cacheFlag</td><td>The optional flag sent to the renderer. The value describes how the cache implementation should handle the resource. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the created <a class="el" href="classramses_1_1Effect.html" title="An effect describes how an object will be rendered to the screen.">Effect</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resource id of the pool effect </dd></dl>

</div>
</div>
<a id="a2f25555c4706026777d9abc4c8937082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f25555c4706026777d9abc4c8937082">&#9670;&nbsp;</a></span>addResourceDataFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ramses::ResourceDataPool::addResourceDataFile </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a file to the resource data pool, so the contained data can be instantiated via createResourceForScene. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>The file name of the resource file to be added to pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true for success. </dd></dl>

</div>
</div>
<a id="a453216272b4e0045f9b875809b7fc7c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a453216272b4e0045f9b875809b7fc7c2">&#9670;&nbsp;</a></span>addTexture2DData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structramses_1_1resourceId__t.html">resourceId_t</a> ramses::ResourceDataPool::addTexture2DData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a19ee2a3bbf78fdc5ad2d41ffa6d766ed">ETextureFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mipMapCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structramses_1_1MipLevelData.html">MipLevelData</a>&#160;</td>
          <td class="paramname"><em>mipLevelData</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>generateMipChain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structramses_1_1TextureSwizzle.html">TextureSwizzle</a> &amp;&#160;</td>
          <td class="paramname"><em>swizzle</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ad235ad0adbf1a441d1339ab3a09159ac">resourceCacheFlag_t</a>&#160;</td>
          <td class="paramname"><em>cacheFlag</em> = <code><a class="el" href="namespaceramses.html#aa4f32a02a4d27b0759cf54915b6ce602">ResourceCacheFlag_DoNotCache</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add <a class="el" href="classramses_1_1Texture2D.html" title="Texture represents a 2-D texture resource.">Texture2D</a> data to the pool. It is taking ownership of the given range of texture data in the specified pixel format and keeps it to instantiate resource from it later via createResourceForScene. See <a class="el" href="classramses_1_1Texture2D.html" title="Texture represents a 2-D texture resource.">ramses::Texture2D</a> for more details. </p>
<p>Readding the same resource data again will return the previous resource id, but not recreate the resource data. Readding a same resource requires removing it again with removeResourceData.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Pixel format of the <a class="el" href="classramses_1_1Texture2D.html" title="Texture represents a 2-D texture resource.">Texture2D</a> data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>Width of the texture (mipmap level 0). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>Height of the texture (mipmap level 0). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mipMapCount</td><td>Number of mipmap levels contained in mipLevelData array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mipLevelData</td><td>Array of <a class="el" href="structramses_1_1MipLevelData.html" title="Struct containing information about one mip-map level of a texture.">MipLevelData</a> structs defining mipmap levels to use. Amount and sizes of supplied mipmap levels have to conform to GL specification. Order is lowest level (biggest resolution) to highest level (smallest resolution). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swizzle</td><td>Describes how RGBA channels of the texture are swizzled, where each member of the struct represents one destination channel that the source channel should get sampled from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">generateMipChain</td><td>Auto generate mipmap levels. Cannot be used if custom data for lower mipmap levels provided. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cacheFlag</td><td>The optional flag sent to the renderer. The value describes how the cache implementation should handle the resource. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the <a class="el" href="classramses_1_1Texture2D.html" title="Texture represents a 2-D texture resource.">Texture2D</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resource id of the pool <a class="el" href="classramses_1_1Texture2D.html" title="Texture represents a 2-D texture resource.">Texture2D</a> resource </dd></dl>

</div>
</div>
<a id="ac88a1a98ff49acd37893b49c4d08d706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac88a1a98ff49acd37893b49c4d08d706">&#9670;&nbsp;</a></span>addTexture3DData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structramses_1_1resourceId__t.html">resourceId_t</a> ramses::ResourceDataPool::addTexture3DData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a19ee2a3bbf78fdc5ad2d41ffa6d766ed">ETextureFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mipMapCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structramses_1_1MipLevelData.html">MipLevelData</a>&#160;</td>
          <td class="paramname"><em>mipLevelData</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>generateMipChain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ad235ad0adbf1a441d1339ab3a09159ac">resourceCacheFlag_t</a>&#160;</td>
          <td class="paramname"><em>cacheFlag</em> = <code><a class="el" href="namespaceramses.html#aa4f32a02a4d27b0759cf54915b6ce602">ResourceCacheFlag_DoNotCache</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add <a class="el" href="classramses_1_1Texture3D.html" title="Texture represents a texture resource.">Texture3D</a> data to the pool. It is taking ownership of the given range of texture data in the specified pixel format and keeps it to instantiate resource from it later via createResourceForScene. See <a class="el" href="classramses_1_1Texture3D.html" title="Texture represents a texture resource.">ramses::Texture3D</a> for more details. Readding the same resource data again will return the previous resource id, but not recreate the resource data. Readding a same resource requires removing it again with removeResourceData. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Pixel format of the <a class="el" href="classramses_1_1Texture3D.html" title="Texture represents a texture resource.">Texture3D</a> data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>Width of the texture (mipmap level 0). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>Height of the texture (mipmap level 0). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>Depth of the texture. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mipMapCount</td><td>Number of mipmap levels contained in mipLevelData array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mipLevelData</td><td>Array of <a class="el" href="structramses_1_1MipLevelData.html" title="Struct containing information about one mip-map level of a texture.">MipLevelData</a> structs defining mipmap levels to use. Amount and sizes of supplied mipmap levels have to conform to GL specification. Order is lowest level (biggest resolution) to highest level (smallest resolution). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">generateMipChain</td><td>Auto generate mipmap levels. Cannot be used if custom data for lower mipmap levels provided. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cacheFlag</td><td>The optional flag sent to the renderer. The value describes how the cache implementation should handle the resource. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the <a class="el" href="classramses_1_1Texture3D.html" title="Texture represents a texture resource.">Texture3D</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resource id of the pool <a class="el" href="classramses_1_1Texture3D.html" title="Texture represents a texture resource.">Texture3D</a> resource </dd></dl>

</div>
</div>
<a id="ab98cb48abafaa5e63e740d0c8c43c51d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab98cb48abafaa5e63e740d0c8c43c51d">&#9670;&nbsp;</a></span>addTextureCubeData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structramses_1_1resourceId__t.html">resourceId_t</a> ramses::ResourceDataPool::addTextureCubeData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a19ee2a3bbf78fdc5ad2d41ffa6d766ed">ETextureFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mipMapCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structramses_1_1CubeMipLevelData.html">CubeMipLevelData</a>&#160;</td>
          <td class="paramname"><em>mipLevelData</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>generateMipChain</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structramses_1_1TextureSwizzle.html">TextureSwizzle</a> &amp;&#160;</td>
          <td class="paramname"><em>swizzle</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ad235ad0adbf1a441d1339ab3a09159ac">resourceCacheFlag_t</a>&#160;</td>
          <td class="paramname"><em>cacheFlag</em> = <code><a class="el" href="namespaceramses.html#aa4f32a02a4d27b0759cf54915b6ce602">ResourceCacheFlag_DoNotCache</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add Cube Texture data to the pool. It is taking ownership of the given range of texture data in the specified pixel format and keeps it to instantiate resource from it later via createResourceForScene. All texel values are initially initialized to 0. See <a class="el" href="classramses_1_1TextureCube.html" title="TextureCube stores pixel data with 6 equally sized quadratic faces.">ramses::TextureCube</a> for more details. Readding the same resource data again will return the previous resource id, but not recreate the resource data. Readding a same resource requires removing it again with removeResourceData. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Pixel format of the Cube Texture data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>edge length of one quadratic cube face, belonging to the texture. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mipMapCount</td><td>Number of mipmaps contained in mipLevelData array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mipLevelData</td><td>Array of <a class="el" href="structramses_1_1MipLevelData.html" title="Struct containing information about one mip-map level of a texture.">MipLevelData</a> structs defining mipmap levels to use. Amount and sizes of supplied mipmap levels have to conform to GL specification. Order ist lowest level (biggest resolution) to highest level (smallest resolution). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">generateMipChain</td><td>Auto generate mipmap levels. Cannot be used if custom data for lower mipmap levels provided. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swizzle</td><td>Describes how RGBA channels of the texture are swizzled, </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cacheFlag</td><td>The optional flag sent to the renderer. The value describes how the cache implementation should handle the resource. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the Cube Texture. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resource id of the pool Cube Texture resource </dd></dl>

</div>
</div>
<a id="a66fa9df892c8dc8e9dc47693910936e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66fa9df892c8dc8e9dc47693910936e2">&#9670;&nbsp;</a></span>createResourceForScene()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classramses_1_1Resource.html">Resource</a>* ramses::ResourceDataPool::createResourceForScene </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classramses_1_1Scene.html">Scene</a> &amp;&#160;</td>
          <td class="paramname"><em>scene</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structramses_1_1resourceId__t.html">resourceId_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a resource for a scene out of pool data. The resource can then be used in scene as if created with the scenes create resource functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scene</td><td>The scene to instantiate the resource in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The resource id of the previously added resource. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the created resource. </dd></dl>

</div>
</div>
<a id="ace9f511265452e08eb0819e912f2237b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace9f511265452e08eb0819e912f2237b">&#9670;&nbsp;</a></span>forceLoadResourcesFromResourceDataFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ramses::ResourceDataPool::forceLoadResourcesFromResourceDataFile </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads all resources in a file currently in use by any scene from that file to memory. </p>
<p>When resources are created via createResourceForScene, not the full resource data is loaded immediately, but lazily at a later time when the data is actually needed. This function will fully load all resources which are currently instantiated in any scene and make sure resources are complete and independent of the resource file.</p>
<p>This operation can be used to trigger the potentially heavy resource loading at a user chosen, most convenient point in time to ensure fast resource handling once the resource is actually used for rendering.</p>
<p>This operation is recommended to be called before removeResourceDataFile to avoid removing a resource file whose resource data hasn't been fully loaded yet for all its resources in any scene.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>The file name of the resource file resource are supposed to force loaded from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true for success. </dd></dl>

</div>
</div>
<a id="a37ece31cb38b75149375fbf15d3dbf7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ece31cb38b75149375fbf15d3dbf7a">&#9670;&nbsp;</a></span>getLastEffectErrorMessages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ramses::ResourceDataPool::getLastEffectErrorMessages </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the GLSL error messages that were produced at the creation of the last <a class="el" href="classramses_1_1Effect.html" title="An effect describes how an object will be rendered to the screen.">Effect</a> data. </p>
<dl class="section return"><dt>Returns</dt><dd>A string containing the GLSL error messages of the last effect </dd></dl>

</div>
</div>
<a id="a0540e5cf6761651dcf5ff8766bdc2ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0540e5cf6761651dcf5ff8766bdc2ae5">&#9670;&nbsp;</a></span>removeResourceData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ramses::ResourceDataPool::removeResourceData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structramses_1_1resourceId__t.html">resourceId_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes data which was added to the pool. The provided resource id might not be used anymore to instantiate a resource via createResourceForScene, depending on how many times corresponding addResourceData was called before. Already instantiated resources will not be affected by removeResourceData. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The resource id of the previously added resource data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true for success. </dd></dl>

</div>
</div>
<a id="ac0f33d0b19ec2c60deac05d95b801e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0f33d0b19ec2c60deac05d95b801e71">&#9670;&nbsp;</a></span>removeResourceDataFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ramses::ResourceDataPool::removeResourceDataFile </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a resource file from the pool. The contained data can then not be used anymore to instantiate a resource via createResourceForScene. </p>
<p>Calling this function might make resource data contained in the file unavailable for loading which leads to a scene not being rendered or rendered in a wrong way. It is recommended to call forceLoadResourcesFromResourceDataFile before to make sure all resource data is in memory and don't do any other resource operation before calling removeResourceDataFile.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>The file name of the resource file to be removed from pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true for success. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ac004d8d7200d41ee843cea624fad9731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac004d8d7200d41ee843cea624fad9731">&#9670;&nbsp;</a></span>RamsesClientImpl</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class RamsesClientImpl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>RamsesClientImpl is the factory for creating the <a class="el" href="classramses_1_1ResourceDataPool.html" title="The ResourceDataPool holds resource data which can be instantiated for a given scene....">ResourceDataPool</a> instance. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ad1a91dfcc151202a8faac2d98a1b83df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1a91dfcc151202a8faac2d98a1b83df">&#9670;&nbsp;</a></span>impl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ResourceDataPoolImpl&amp; ramses::ResourceDataPool::impl</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores internal data for implementation specifics of <a class="el" href="classramses_1_1ResourceDataPool.html" title="The ResourceDataPool holds resource data which can be instantiated for a given scene....">ResourceDataPool</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/q479079/sources/ramses-oss/client/ramses-client/ramses-client-api/include/ramses-client-api/<a class="el" href="ResourceDataPool_8h_source.html">ResourceDataPool.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
