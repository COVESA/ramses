<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RAMSES Documentation: ramses::RamsesRenderer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ramses_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RAMSES Documentation
   &#160;<span id="projectnumber">27.0.117</span>
   </div>
   <div id="projectbrief">Information for RAMSES users and developers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceramses.html">ramses</a></li><li class="navelem"><a class="el" href="classramses_1_1RamsesRenderer.html">RamsesRenderer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classramses_1_1RamsesRenderer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ramses::RamsesRenderer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classramses_1_1RamsesRenderer.html" title="RamsesRenderer is the main renderer component which provides API to configure and control the way con...">RamsesRenderer</a> is the main renderer component which provides API to configure and control the way content will be rendered on display(s).  
 <a href="classramses_1_1RamsesRenderer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="RamsesRenderer_8h_source.html">RamsesRenderer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ramses::RamsesRenderer:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classramses_1_1RamsesRenderer__inherit__graph.svg" width="200" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for ramses::RamsesRenderer:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classramses_1_1RamsesRenderer__coll__graph.svg" width="200" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8bceaf9ed2fd659a05d2b12645a6bfdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a8bceaf9ed2fd659a05d2b12645a6bfdd">doOneLoop</a> ()</td></tr>
<tr class="memdesc:a8bceaf9ed2fd659a05d2b12645a6bfdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare content to be rendered in next frame and render next frame.  <a href="classramses_1_1RamsesRenderer.html#a8bceaf9ed2fd659a05d2b12645a6bfdd">More...</a><br /></td></tr>
<tr class="separator:a8bceaf9ed2fd659a05d2b12645a6bfdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90489cf440602591c90f7a08bb5958ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a90489cf440602591c90f7a08bb5958ab">startThread</a> ()</td></tr>
<tr class="memdesc:a90489cf440602591c90f7a08bb5958ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts update and render loop in threaded mode.  <a href="classramses_1_1RamsesRenderer.html#a90489cf440602591c90f7a08bb5958ab">More...</a><br /></td></tr>
<tr class="separator:a90489cf440602591c90f7a08bb5958ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01dd58f37a2a782bcb77e25bea81175c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a01dd58f37a2a782bcb77e25bea81175c">stopThread</a> ()</td></tr>
<tr class="memdesc:a01dd58f37a2a782bcb77e25bea81175c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops thread(s) running the update and render of displays.  <a href="classramses_1_1RamsesRenderer.html#a01dd58f37a2a782bcb77e25bea81175c">More...</a><br /></td></tr>
<tr class="separator:a01dd58f37a2a782bcb77e25bea81175c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd3f2d1e4f5782019544a52edb8bf2e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a2bd3f2d1e4f5782019544a52edb8bf2e">isThreadRunning</a> () const</td></tr>
<tr class="memdesc:a2bd3f2d1e4f5782019544a52edb8bf2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current state of rendering thread(s) running.  <a href="classramses_1_1RamsesRenderer.html#a2bd3f2d1e4f5782019544a52edb8bf2e">More...</a><br /></td></tr>
<tr class="separator:a2bd3f2d1e4f5782019544a52edb8bf2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96181331eab7ab60dd607a3bcab999a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a96181331eab7ab60dd607a3bcab999a6">setMaximumFramerate</a> (float maximumFramerate)</td></tr>
<tr class="memdesc:a96181331eab7ab60dd607a3bcab999a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum frame rate per second for the update/render loop when in threaded mode.  <a href="classramses_1_1RamsesRenderer.html#a96181331eab7ab60dd607a3bcab999a6">More...</a><br /></td></tr>
<tr class="separator:a96181331eab7ab60dd607a3bcab999a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d5685d38fb82c58e13f9274ce087d5"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#ac8d5685d38fb82c58e13f9274ce087d5">getMaximumFramerate</a> () const</td></tr>
<tr class="memdesc:ac8d5685d38fb82c58e13f9274ce087d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current value for maximum frame rate per second currently set (<a class="el" href="classramses_1_1RamsesRenderer.html#a96181331eab7ab60dd607a3bcab999a6" title="Sets the maximum frame rate per second for the update/render loop when in threaded mode.">setMaximumFramerate</a>).  <a href="classramses_1_1RamsesRenderer.html#ac8d5685d38fb82c58e13f9274ce087d5">More...</a><br /></td></tr>
<tr class="separator:ac8d5685d38fb82c58e13f9274ce087d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2203f9f2e6a6ab233809e1ee85367d89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a2203f9f2e6a6ab233809e1ee85367d89">setLoopMode</a> (<a class="el" href="namespaceramses.html#adcfa3b1b4a623dea062782aefa84e002">ELoopMode</a> loopMode)</td></tr>
<tr class="memdesc:a2203f9f2e6a6ab233809e1ee85367d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the mode of operation for render loop.  <a href="classramses_1_1RamsesRenderer.html#a2203f9f2e6a6ab233809e1ee85367d89">More...</a><br /></td></tr>
<tr class="separator:a2203f9f2e6a6ab233809e1ee85367d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af865674d0f4270c9e846a6f1b8ad2053"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#adcfa3b1b4a623dea062782aefa84e002">ELoopMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#af865674d0f4270c9e846a6f1b8ad2053">getLoopMode</a> () const</td></tr>
<tr class="memdesc:af865674d0f4270c9e846a6f1b8ad2053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current value for loop mode set using <a class="el" href="classramses_1_1RamsesRenderer.html#a2203f9f2e6a6ab233809e1ee85367d89" title="Sets the mode of operation for render loop.">setLoopMode</a>.  <a href="classramses_1_1RamsesRenderer.html#af865674d0f4270c9e846a6f1b8ad2053">More...</a><br /></td></tr>
<tr class="separator:af865674d0f4270c9e846a6f1b8ad2053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac371e5e8e6a581a8d16f39e9ece1ed99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#ac371e5e8e6a581a8d16f39e9ece1ed99">setFrameTimerLimits</a> (uint64_t limitForSceneResourcesUpload, uint64_t limitForClientResourcesUpload, uint64_t limitForOffscreenBufferRender)</td></tr>
<tr class="memdesc:ac371e5e8e6a581a8d16f39e9ece1ed99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets time limits for time-out of different sections of render and update loop.  <a href="classramses_1_1RamsesRenderer.html#ac371e5e8e6a581a8d16f39e9ece1ed99">More...</a><br /></td></tr>
<tr class="separator:ac371e5e8e6a581a8d16f39e9ece1ed99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26564ba54af9e15729e43b86425826bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a26564ba54af9e15729e43b86425826bd">setPendingFlushLimits</a> (uint32_t forceApplyFlushLimit, uint32_t forceUnsubscribeSceneLimit)</td></tr>
<tr class="memdesc:a26564ba54af9e15729e43b86425826bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of pending flushes accepted before force-applying them to their scene, or forcefully insubscribing the scene.  <a href="classramses_1_1RamsesRenderer.html#a26564ba54af9e15729e43b86425826bd">More...</a><br /></td></tr>
<tr class="separator:a26564ba54af9e15729e43b86425826bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1077a8cd9283f6e313d646459815c931"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a1077a8cd9283f6e313d646459815c931">setSkippingOfUnmodifiedBuffers</a> (bool enable=true)</td></tr>
<tr class="memdesc:a1077a8cd9283f6e313d646459815c931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable skipping of rendering of unmodified buffers. By default the renderer does not re-render buffers (framebuffer or offscreen buffer) if there was no change to any of the content assigned to the buffer. This can save hardware resources or free up resources for rendering of other buffers. It can be however desired to disable such optimization for profiling of worst case scenario or debugging of a graphical glitch.  <a href="classramses_1_1RamsesRenderer.html#a1077a8cd9283f6e313d646459815c931">More...</a><br /></td></tr>
<tr class="separator:a1077a8cd9283f6e313d646459815c931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8715c650b5617440220f6980f8cfbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a5e8715c650b5617440220f6980f8cfbe">createDisplay</a> (const <a class="el" href="classramses_1_1DisplayConfig.html">DisplayConfig</a> &amp;config)</td></tr>
<tr class="memdesc:a5e8715c650b5617440220f6980f8cfbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a display based on provided display config. Creation of a display is an asynchronous action and the display will be created during the next render loop. The result of the createDisplay can be retrieved via dispatchEvents which will trigger a callback after the asynchronous action was processed.  <a href="classramses_1_1RamsesRenderer.html#a5e8715c650b5617440220f6980f8cfbe">More...</a><br /></td></tr>
<tr class="separator:a5e8715c650b5617440220f6980f8cfbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d683d3ec9bdfae4e63a27d99f9bf9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#ac1d683d3ec9bdfae4e63a27d99f9bf9e">destroyDisplay</a> (<a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a> displayId)</td></tr>
<tr class="memdesc:ac1d683d3ec9bdfae4e63a27d99f9bf9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a display. Destruction of a display is an asynchronous action and the actual display components (window, device, etc.) will be released during the next render loop. The result of the destroyDisplay can be retrieved via dispatchEvents which will trigger a callback with the result after the asynchronous action was processed.  <a href="classramses_1_1RamsesRenderer.html#ac1d683d3ec9bdfae4e63a27d99f9bf9e">More...</a><br /></td></tr>
<tr class="separator:ac1d683d3ec9bdfae4e63a27d99f9bf9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addff71feff4e101e665631b6b27363a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#addff71feff4e101e665631b6b27363a6">getDisplayFramebuffer</a> (<a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a> displayId) const</td></tr>
<tr class="memdesc:addff71feff4e101e665631b6b27363a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get display's framebuffer ID. Every display upon creation has one framebuffer which can be referenced by a display buffer ID to be used in various API methods that work with either a framebuffer or an offscreen buffer (e.g. RamsesRenderer::setBufferClearColor).  <a href="classramses_1_1RamsesRenderer.html#addff71feff4e101e665631b6b27363a6">More...</a><br /></td></tr>
<tr class="separator:addff71feff4e101e665631b6b27363a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc19bf22f0c5fd8e4559e544703ac9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#addc19bf22f0c5fd8e4559e544703ac9a">createOffscreenBuffer</a> (<a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a> display, uint32_t width, uint32_t height, uint32_t sampleCount=0u)</td></tr>
<tr class="memdesc:addc19bf22f0c5fd8e4559e544703ac9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will create an offscreen buffer that can be used to render scenes into (see <a class="el" href="classramses_1_1RendererSceneControl.html#a865b4e80546bf49191ec6307f0c39b17" title="Set scene display buffer assignment.">ramses::RendererSceneControl::setSceneDisplayBufferAssignment</a>) and can be linked as input to a consumer texture sampler (see <a class="el" href="classramses_1_1RendererSceneControl.html#a404275629b0b73ad04d10f4a1649e8ba" title="Links display&#39;s offscreen buffer to a data consumer in scene.">ramses::RendererSceneControl::linkOffscreenBuffer</a>).  <a href="classramses_1_1RamsesRenderer.html#addc19bf22f0c5fd8e4559e544703ac9a">More...</a><br /></td></tr>
<tr class="separator:addc19bf22f0c5fd8e4559e544703ac9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3e4d6c6573f9333034bc2d711101b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#aba3e4d6c6573f9333034bc2d711101b0">createInterruptibleOffscreenBuffer</a> (<a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a> display, uint32_t width, uint32_t height)</td></tr>
<tr class="memdesc:aba3e4d6c6573f9333034bc2d711101b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional API to create an offscreen buffer as interruptible. (see <a class="el" href="classramses_1_1RamsesRenderer.html#addc19bf22f0c5fd8e4559e544703ac9a" title="Will create an offscreen buffer that can be used to render scenes into (see ramses::RendererSceneCont...">createOffscreenBuffer</a>)  <a href="classramses_1_1RamsesRenderer.html#aba3e4d6c6573f9333034bc2d711101b0">More...</a><br /></td></tr>
<tr class="separator:aba3e4d6c6573f9333034bc2d711101b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2325f5f74258cf4bd68b54b5403aae0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#aa2325f5f74258cf4bd68b54b5403aae0">createDmaOffscreenBuffer</a> (<a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a> display, uint32_t width, uint32_t height, uint32_t bufferFourccFormat, uint32_t usageFlags, uint64_t modifier)</td></tr>
<tr class="memdesc:aa2325f5f74258cf4bd68b54b5403aae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional API to create an offscreen buffer using DMA buffer for internal storage. (see <a class="el" href="classramses_1_1RamsesRenderer.html#addc19bf22f0c5fd8e4559e544703ac9a" title="Will create an offscreen buffer that can be used to render scenes into (see ramses::RendererSceneCont...">createOffscreenBuffer</a>)  <a href="classramses_1_1RamsesRenderer.html#aa2325f5f74258cf4bd68b54b5403aae0">More...</a><br /></td></tr>
<tr class="separator:aa2325f5f74258cf4bd68b54b5403aae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3f7a514085d2e6643d841bbb69b41d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#aab3f7a514085d2e6643d841bbb69b41d">getDmaOffscreenBufferFDAndStride</a> (<a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a> display, <a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a> displayBufferId, int &amp;fd, uint32_t &amp;stride) const</td></tr>
<tr class="memdesc:aab3f7a514085d2e6643d841bbb69b41d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the FD and stride for a DMA offscreen buffer previously created on the given display.  <a href="classramses_1_1RamsesRenderer.html#aab3f7a514085d2e6643d841bbb69b41d">More...</a><br /></td></tr>
<tr class="separator:aab3f7a514085d2e6643d841bbb69b41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e4ab2cf1d3c87290c4eeac5cd207e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a92e4ab2cf1d3c87290c4eeac5cd207e8">destroyOffscreenBuffer</a> (<a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a> display, <a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a> offscreenBuffer)</td></tr>
<tr class="memdesc:a92e4ab2cf1d3c87290c4eeac5cd207e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will destroy a previously created offscreen buffer. If there are any consumer texture samplers linked to this buffer, these links will be removed. Offscreen buffer will fail to be destroyed if there are any scenes assigned to it, these scenes have to be first assigned to another buffer or framebuffer or unmapped from display.  <a href="classramses_1_1RamsesRenderer.html#a92e4ab2cf1d3c87290c4eeac5cd207e8">More...</a><br /></td></tr>
<tr class="separator:a92e4ab2cf1d3c87290c4eeac5cd207e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615fece250e98bdfde5fae979b55b24e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a615fece250e98bdfde5fae979b55b24e">setDisplayBufferClearColor</a> (<a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a> display, <a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a> displayBuffer, float r, float g, float b, float a)</td></tr>
<tr class="memdesc:a615fece250e98bdfde5fae979b55b24e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets clear color of a display buffer (display's framebuffer or offscreen buffer).  <a href="classramses_1_1RamsesRenderer.html#a615fece250e98bdfde5fae979b55b24e">More...</a><br /></td></tr>
<tr class="separator:a615fece250e98bdfde5fae979b55b24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b8b49e394f9676224f6a55e6413862"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a88b8b49e394f9676224f6a55e6413862">readPixels</a> (<a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a> displayId, <a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a> displayBuffer, uint32_t x, uint32_t y, uint32_t width, uint32_t height)</td></tr>
<tr class="memdesc:a88b8b49e394f9676224f6a55e6413862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triggers an asynchronous read back of a display buffer memory from GPU to system memory.  <a href="classramses_1_1RamsesRenderer.html#a88b8b49e394f9676224f6a55e6413862">More...</a><br /></td></tr>
<tr class="separator:a88b8b49e394f9676224f6a55e6413862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca664b15215a8cb1f410db4da3c65296"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classramses_1_1RendererSceneControl.html">RendererSceneControl</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#aca664b15215a8cb1f410db4da3c65296">getSceneControlAPI</a> ()</td></tr>
<tr class="memdesc:aca664b15215a8cb1f410db4da3c65296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get scene control API.  <a href="classramses_1_1RamsesRenderer.html#aca664b15215a8cb1f410db4da3c65296">More...</a><br /></td></tr>
<tr class="separator:aca664b15215a8cb1f410db4da3c65296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c18812bd5b480e6373cc9c1949564ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classramses_1_1DcsmContentControl.html">DcsmContentControl</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a3c18812bd5b480e6373cc9c1949564ca">createDcsmContentControl</a> ()</td></tr>
<tr class="memdesc:a3c18812bd5b480e6373cc9c1949564ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classramses_1_1DcsmContentControl.html" title="DcsmContentControl provides way to interact with both Dcsm (as consumer) and renderer content control...">ramses::DcsmContentControl</a> to control content states.  <a href="classramses_1_1RamsesRenderer.html#a3c18812bd5b480e6373cc9c1949564ca">More...</a><br /></td></tr>
<tr class="separator:a3c18812bd5b480e6373cc9c1949564ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6732097772becc5818ba94f7aa845a10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a6732097772becc5818ba94f7aa845a10">setSurfaceVisibility</a> (uint32_t surfaceId, bool visibility)</td></tr>
<tr class="memdesc:a6732097772becc5818ba94f7aa845a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set visibility of given surface at the system compositor.  <a href="classramses_1_1RamsesRenderer.html#a6732097772becc5818ba94f7aa845a10">More...</a><br /></td></tr>
<tr class="separator:a6732097772becc5818ba94f7aa845a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254d5d21f8685117aeea48cf4a26bde0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a254d5d21f8685117aeea48cf4a26bde0">setSurfaceOpacity</a> (uint32_t surfaceId, float opacity)</td></tr>
<tr class="memdesc:a254d5d21f8685117aeea48cf4a26bde0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set opacity of given surface at the system compositor.  <a href="classramses_1_1RamsesRenderer.html#a254d5d21f8685117aeea48cf4a26bde0">More...</a><br /></td></tr>
<tr class="separator:a254d5d21f8685117aeea48cf4a26bde0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9354989524cb902ba736b2e897e5e82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#ad9354989524cb902ba736b2e897e5e82">setSurfaceRectangle</a> (uint32_t surfaceId, int32_t x, int32_t y, int32_t width, int32_t height)</td></tr>
<tr class="memdesc:ad9354989524cb902ba736b2e897e5e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set output rectangle of given surface at the system compositor.  <a href="classramses_1_1RamsesRenderer.html#ad9354989524cb902ba736b2e897e5e82">More...</a><br /></td></tr>
<tr class="separator:ad9354989524cb902ba736b2e897e5e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b316650d87b61a4dbf4f8c19bd23807"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a2b316650d87b61a4dbf4f8c19bd23807">setLayerVisibility</a> (uint32_t layerId, bool visibility)</td></tr>
<tr class="memdesc:a2b316650d87b61a4dbf4f8c19bd23807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set visibility of given layer at the system compositor.  <a href="classramses_1_1RamsesRenderer.html#a2b316650d87b61a4dbf4f8c19bd23807">More...</a><br /></td></tr>
<tr class="separator:a2b316650d87b61a4dbf4f8c19bd23807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6dd092a73ecf218c36a6dffaddbea0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a0e6dd092a73ecf218c36a6dffaddbea0">takeSystemCompositorScreenshot</a> (const char *fileName, int32_t screenIviId)</td></tr>
<tr class="memdesc:a0e6dd092a73ecf218c36a6dffaddbea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger the System Compositor to take a screenshot and store it in a file.  <a href="classramses_1_1RamsesRenderer.html#a0e6dd092a73ecf218c36a6dffaddbea0">More...</a><br /></td></tr>
<tr class="separator:a0e6dd092a73ecf218c36a6dffaddbea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ef2b5e6b42052bd5ad6c7a61fe78f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a56ef2b5e6b42052bd5ad6c7a61fe78f2">updateWarpingMeshData</a> (<a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a> displayId, const <a class="el" href="classramses_1_1WarpingMeshData.html">WarpingMeshData</a> &amp;newWarpingMeshData)</td></tr>
<tr class="memdesc:a56ef2b5e6b42052bd5ad6c7a61fe78f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the warping mesh for the warping postprocessing based on the new config.  <a href="classramses_1_1RamsesRenderer.html#a56ef2b5e6b42052bd5ad6c7a61fe78f2">More...</a><br /></td></tr>
<tr class="separator:a56ef2b5e6b42052bd5ad6c7a61fe78f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aeedaa36dd7cc51bbf657298b2a0419"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a7aeedaa36dd7cc51bbf657298b2a0419">dispatchEvents</a> (<a class="el" href="classramses_1_1IRendererEventHandler.html">IRendererEventHandler</a> &amp;rendererEventHandler)</td></tr>
<tr class="memdesc:a7aeedaa36dd7cc51bbf657298b2a0419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Most <a class="el" href="classramses_1_1RamsesRenderer.html" title="RamsesRenderer is the main renderer component which provides API to configure and control the way con...">RamsesRenderer</a> methods push commands to an internal queue which is submitted when calling <a class="el" href="classramses_1_1RamsesRenderer.html#a6307f22a698040fc1f68f771a39ff253" title="Submits renderer commands (API calls on this instance of RamsesRenderer) since previous flush to be e...">RamsesRenderer::flush</a>. The commands are then executed during a render loop (<a class="el" href="classramses_1_1RamsesRenderer.html#a8bceaf9ed2fd659a05d2b12645a6bfdd" title="Prepare content to be rendered in next frame and render next frame.">RamsesRenderer::doOneLoop</a> or in a render thread if used <a class="el" href="classramses_1_1RamsesRenderer.html#a90489cf440602591c90f7a08bb5958ab" title="Starts update and render loop in threaded mode.">RamsesRenderer::startThread</a>). Some of these calls result in an event (can be both informational and data). Such events and their result can be retrieved using the dispatchEvents call. <em>IMPORTANT</em> Renderer events must be regularly consumed by calling <a class="el" href="classramses_1_1RamsesRenderer.html#a7aeedaa36dd7cc51bbf657298b2a0419" title="Most RamsesRenderer methods push commands to an internal queue which is submitted when calling Ramses...">dispatchEvents()</a> in order to prevent buffer overflow of the internal event queue, even if the application is not interested in those events.  <a href="classramses_1_1RamsesRenderer.html#a7aeedaa36dd7cc51bbf657298b2a0419">More...</a><br /></td></tr>
<tr class="separator:a7aeedaa36dd7cc51bbf657298b2a0419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6307f22a698040fc1f68f771a39ff253"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a6307f22a698040fc1f68f771a39ff253">flush</a> ()</td></tr>
<tr class="memdesc:a6307f22a698040fc1f68f771a39ff253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits renderer commands (API calls on this instance of <a class="el" href="classramses_1_1RamsesRenderer.html" title="RamsesRenderer is the main renderer component which provides API to configure and control the way con...">RamsesRenderer</a>) since previous flush to be executed in the next renderer update loop.  <a href="classramses_1_1RamsesRenderer.html#a6307f22a698040fc1f68f771a39ff253">More...</a><br /></td></tr>
<tr class="separator:a6307f22a698040fc1f68f771a39ff253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1cdc22128187b688f9c236b0109004"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a8e1cdc22128187b688f9c236b0109004">logRendererInfo</a> ()</td></tr>
<tr class="memdesc:a8e1cdc22128187b688f9c236b0109004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints detailed information about renderer state and contents to the log output.  <a href="classramses_1_1RamsesRenderer.html#a8e1cdc22128187b688f9c236b0109004">More...</a><br /></td></tr>
<tr class="separator:a8e1cdc22128187b688f9c236b0109004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40fec1c0331111e1f1a24f946bd961c3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a40fec1c0331111e1f1a24f946bd961c3">RamsesRenderer</a> (RamsesRendererImpl &amp;)</td></tr>
<tr class="memdesc:a40fec1c0331111e1f1a24f946bd961c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of <a class="el" href="classramses_1_1RamsesRenderer.html" title="RamsesRenderer is the main renderer component which provides API to configure and control the way con...">RamsesRenderer</a>.  <a href="classramses_1_1RamsesRenderer.html#a40fec1c0331111e1f1a24f946bd961c3">More...</a><br /></td></tr>
<tr class="separator:a40fec1c0331111e1f1a24f946bd961c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987acea6b24d68446f4ba40300c15183"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a987acea6b24d68446f4ba40300c15183">RamsesRenderer</a> ()=delete</td></tr>
<tr class="memdesc:a987acea6b24d68446f4ba40300c15183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted default constructor.  <a href="classramses_1_1RamsesRenderer.html#a987acea6b24d68446f4ba40300c15183">More...</a><br /></td></tr>
<tr class="separator:a987acea6b24d68446f4ba40300c15183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838a0662f0754430fc64d6791ddb8c7b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a838a0662f0754430fc64d6791ddb8c7b">RamsesRenderer</a> (const <a class="el" href="classramses_1_1RamsesRenderer.html">RamsesRenderer</a> &amp;other)=delete</td></tr>
<tr class="memdesc:a838a0662f0754430fc64d6791ddb8c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy constructor.  <a href="classramses_1_1RamsesRenderer.html#a838a0662f0754430fc64d6791ddb8c7b">More...</a><br /></td></tr>
<tr class="separator:a838a0662f0754430fc64d6791ddb8c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a7307221202b2c07a1637be9b84dde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classramses_1_1RamsesRenderer.html">RamsesRenderer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#ac5a7307221202b2c07a1637be9b84dde">operator=</a> (const <a class="el" href="classramses_1_1RamsesRenderer.html">RamsesRenderer</a> &amp;other)=delete</td></tr>
<tr class="memdesc:ac5a7307221202b2c07a1637be9b84dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy assignment.  <a href="classramses_1_1RamsesRenderer.html#ac5a7307221202b2c07a1637be9b84dde">More...</a><br /></td></tr>
<tr class="separator:ac5a7307221202b2c07a1637be9b84dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classramses_1_1StatusObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classramses_1_1StatusObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classramses_1_1StatusObject.html">ramses::StatusObject</a></td></tr>
<tr class="memitem:a1f22f4fa83016eb344ccb8a20c1e7921 inherit pub_methods_classramses_1_1StatusObject"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1StatusObject.html#a1f22f4fa83016eb344ccb8a20c1e7921">validate</a> () const</td></tr>
<tr class="memdesc:a1f22f4fa83016eb344ccb8a20c1e7921 inherit pub_methods_classramses_1_1StatusObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates verbose validation of the object.  <a href="classramses_1_1StatusObject.html#a1f22f4fa83016eb344ccb8a20c1e7921">More...</a><br /></td></tr>
<tr class="separator:a1f22f4fa83016eb344ccb8a20c1e7921 inherit pub_methods_classramses_1_1StatusObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab194187e116bdfe7b51c97a325d2ed06 inherit pub_methods_classramses_1_1StatusObject"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1StatusObject.html#ab194187e116bdfe7b51c97a325d2ed06">getValidationReport</a> (<a class="el" href="namespaceramses.html#a2fe664af611fc05c4c7a487e195cceab">EValidationSeverity</a> minSeverity=<a class="el" href="namespaceramses.html#a2fe664af611fc05c4c7a487e195cceabad806be26d26e0564001532670b1ccb6f">EValidationSeverity_Info</a>) const</td></tr>
<tr class="memdesc:ab194187e116bdfe7b51c97a325d2ed06 inherit pub_methods_classramses_1_1StatusObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides verbose report in human readable form generated by <a class="el" href="classramses_1_1StatusObject.html#a1f22f4fa83016eb344ccb8a20c1e7921" title="Generates verbose validation of the object.">validate</a>.  <a href="classramses_1_1StatusObject.html#ab194187e116bdfe7b51c97a325d2ed06">More...</a><br /></td></tr>
<tr class="separator:ab194187e116bdfe7b51c97a325d2ed06 inherit pub_methods_classramses_1_1StatusObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fbbfea27c8eb369b1f21de42f2e88b1 inherit pub_methods_classramses_1_1StatusObject"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1">getStatusMessage</a> (<a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> status) const</td></tr>
<tr class="memdesc:a1fbbfea27c8eb369b1f21de42f2e88b1 inherit pub_methods_classramses_1_1StatusObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string description for a status provided by a RAMSES API function.  <a href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1">More...</a><br /></td></tr>
<tr class="separator:a1fbbfea27c8eb369b1f21de42f2e88b1 inherit pub_methods_classramses_1_1StatusObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7d7495b7a081aa9bc3a4b8eac36e19 inherit pub_methods_classramses_1_1StatusObject"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1StatusObject.html#a0e7d7495b7a081aa9bc3a4b8eac36e19">StatusObject</a> (const <a class="el" href="classramses_1_1StatusObject.html">StatusObject</a> &amp;other)=delete</td></tr>
<tr class="memdesc:a0e7d7495b7a081aa9bc3a4b8eac36e19 inherit pub_methods_classramses_1_1StatusObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy constructor.  <a href="classramses_1_1StatusObject.html#a0e7d7495b7a081aa9bc3a4b8eac36e19">More...</a><br /></td></tr>
<tr class="separator:a0e7d7495b7a081aa9bc3a4b8eac36e19 inherit pub_methods_classramses_1_1StatusObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1d8fa3051147db0ecb18c1ce500ee2 inherit pub_methods_classramses_1_1StatusObject"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classramses_1_1StatusObject.html">StatusObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1StatusObject.html#a2e1d8fa3051147db0ecb18c1ce500ee2">operator=</a> (const <a class="el" href="classramses_1_1StatusObject.html">StatusObject</a> &amp;other)=delete</td></tr>
<tr class="memdesc:a2e1d8fa3051147db0ecb18c1ce500ee2 inherit pub_methods_classramses_1_1StatusObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy assignment.  <a href="classramses_1_1StatusObject.html#a2e1d8fa3051147db0ecb18c1ce500ee2">More...</a><br /></td></tr>
<tr class="separator:a2e1d8fa3051147db0ecb18c1ce500ee2 inherit pub_methods_classramses_1_1StatusObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:acabff95b658cc988622b64517cea5567"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#acabff95b658cc988622b64517cea5567">setMaximumFramerate</a> (<a class="el" href="classramses_1_1RamsesRenderer.html">RamsesRenderer</a> &amp;renderer, float maximumFramerate, <a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a> displayId)</td></tr>
<tr class="memdesc:acabff95b658cc988622b64517cea5567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum frame rate per second for the update/render loop when in threaded mode for given display.  <a href="classramses_1_1RamsesRenderer.html#acabff95b658cc988622b64517cea5567">More...</a><br /></td></tr>
<tr class="separator:acabff95b658cc988622b64517cea5567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a471dd6ede67fd75a504ea6b412082a64"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a471dd6ede67fd75a504ea6b412082a64">createOffscreenBuffer</a> (<a class="el" href="classramses_1_1RamsesRenderer.html">RamsesRenderer</a> &amp;renderer, <a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a> display, uint32_t width, uint32_t height, uint32_t sampleCount=0u, <a class="el" href="namespaceramses.html#a2778df9cdbae5cb361850633bfde5895">EDepthBufferType</a> depthBufferType=<a class="el" href="namespaceramses.html#a2778df9cdbae5cb361850633bfde5895aed4959723f8a2a25152521451635dcf1">EDepthBufferType_DepthStencil</a>)</td></tr>
<tr class="memdesc:a471dd6ede67fd75a504ea6b412082a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will create an offscreen buffer that can be used to render scenes into (see <a class="el" href="classramses_1_1RendererSceneControl.html#a865b4e80546bf49191ec6307f0c39b17" title="Set scene display buffer assignment.">ramses::RendererSceneControl::setSceneDisplayBufferAssignment</a>) and can be linked as input to a consumer texture sampler (see <a class="el" href="classramses_1_1RendererSceneControl.html#a404275629b0b73ad04d10f4a1649e8ba" title="Links display&#39;s offscreen buffer to a data consumer in scene.">ramses::RendererSceneControl::linkOffscreenBuffer</a>).  <a href="classramses_1_1RamsesRenderer.html#a471dd6ede67fd75a504ea6b412082a64">More...</a><br /></td></tr>
<tr class="separator:a471dd6ede67fd75a504ea6b412082a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9eb8aa6d3aaa227250256556004ac1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#adf9eb8aa6d3aaa227250256556004ac1">createInterruptibleOffscreenBuffer</a> (<a class="el" href="classramses_1_1RamsesRenderer.html">RamsesRenderer</a> &amp;renderer, <a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a> display, uint32_t width, uint32_t height, <a class="el" href="namespaceramses.html#a2778df9cdbae5cb361850633bfde5895">EDepthBufferType</a> depthBufferType=<a class="el" href="namespaceramses.html#a2778df9cdbae5cb361850633bfde5895aed4959723f8a2a25152521451635dcf1">EDepthBufferType_DepthStencil</a>)</td></tr>
<tr class="memdesc:adf9eb8aa6d3aaa227250256556004ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional API to create an offscreen buffer as interruptible. This allows the renderer to interrupt rendering of scenes to such offscreen buffer if the time budget for rendering is exceeded within a frame (see <a class="el" href="classramses_1_1RamsesRenderer.html#ac371e5e8e6a581a8d16f39e9ece1ed99" title="Sets time limits for time-out of different sections of render and update loop.">setFrameTimerLimits</a>). The rendering continues next frame starting from the interruption point.  <a href="classramses_1_1RamsesRenderer.html#adf9eb8aa6d3aaa227250256556004ac1">More...</a><br /></td></tr>
<tr class="separator:adf9eb8aa6d3aaa227250256556004ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70f64e98a833178ea7729015fb1e7fe"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#ac70f64e98a833178ea7729015fb1e7fe">setDisplayBufferClearFlags</a> (<a class="el" href="classramses_1_1RamsesRenderer.html">RamsesRenderer</a> &amp;renderer, <a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a> display, <a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a> displayBuffer, uint32_t clearFlags)</td></tr>
<tr class="memdesc:ac70f64e98a833178ea7729015fb1e7fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets clear flags for a display buffer (display's framebuffer or offscreen buffer).  <a href="classramses_1_1RamsesRenderer.html#ac70f64e98a833178ea7729015fb1e7fe">More...</a><br /></td></tr>
<tr class="separator:ac70f64e98a833178ea7729015fb1e7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a116e218cbff71ef947bdb765a7220559"><td class="memItemLeft" align="right" valign="top">class RamsesRendererImpl &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#a116e218cbff71ef947bdb765a7220559">impl</a></td></tr>
<tr class="separator:a116e218cbff71ef947bdb765a7220559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classramses_1_1StatusObject"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classramses_1_1StatusObject')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classramses_1_1StatusObject.html">ramses::StatusObject</a></td></tr>
<tr class="memitem:a248c9883d91fdb952853f4e46f5daca6 inherit pub_attribs_classramses_1_1StatusObject"><td class="memItemLeft" align="right" valign="top">class StatusObjectImpl &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1StatusObject.html#a248c9883d91fdb952853f4e46f5daca6">impl</a></td></tr>
<tr class="separator:a248c9883d91fdb952853f4e46f5daca6 inherit pub_attribs_classramses_1_1StatusObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ad73693270161e42d1d5f034d5c74b4db"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RamsesRenderer.html#ad73693270161e42d1d5f034d5c74b4db">RendererFactory</a></td></tr>
<tr class="memdesc:ad73693270161e42d1d5f034d5c74b4db"><td class="mdescLeft">&#160;</td><td class="mdescRight">RendererFactory is the factory for <a class="el" href="classramses_1_1RamsesRenderer.html" title="RamsesRenderer is the main renderer component which provides API to configure and control the way con...">RamsesRenderer</a>.  <a href="classramses_1_1RamsesRenderer.html#ad73693270161e42d1d5f034d5c74b4db">More...</a><br /></td></tr>
<tr class="separator:ad73693270161e42d1d5f034d5c74b4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classramses_1_1StatusObject"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classramses_1_1StatusObject')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classramses_1_1StatusObject.html">ramses::StatusObject</a></td></tr>
<tr class="memitem:a19aaed5d79ca0590e38e800734e65751 inherit pro_methods_classramses_1_1StatusObject"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1StatusObject.html#a19aaed5d79ca0590e38e800734e65751">StatusObject</a> (StatusObjectImpl &amp;pimpl)</td></tr>
<tr class="memdesc:a19aaed5d79ca0590e38e800734e65751 inherit pro_methods_classramses_1_1StatusObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for <a class="el" href="classramses_1_1StatusObject.html" title="The StatusObject provides status message handling.">StatusObject</a>.  <a href="classramses_1_1StatusObject.html#a19aaed5d79ca0590e38e800734e65751">More...</a><br /></td></tr>
<tr class="separator:a19aaed5d79ca0590e38e800734e65751 inherit pro_methods_classramses_1_1StatusObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdea643fe5ab0db7ad2bf888928ff48a inherit pro_methods_classramses_1_1StatusObject"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1StatusObject.html#afdea643fe5ab0db7ad2bf888928ff48a">~StatusObject</a> ()</td></tr>
<tr class="memdesc:afdea643fe5ab0db7ad2bf888928ff48a inherit pro_methods_classramses_1_1StatusObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor of the <a class="el" href="classramses_1_1StatusObject.html" title="The StatusObject provides status message handling.">StatusObject</a>.  <a href="classramses_1_1StatusObject.html#afdea643fe5ab0db7ad2bf888928ff48a">More...</a><br /></td></tr>
<tr class="separator:afdea643fe5ab0db7ad2bf888928ff48a inherit pro_methods_classramses_1_1StatusObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classramses_1_1RamsesRenderer.html" title="RamsesRenderer is the main renderer component which provides API to configure and control the way con...">RamsesRenderer</a> is the main renderer component which provides API to configure and control the way content will be rendered on display(s). </p>
<p>All the commands in this class are put to a queue and submitted only when <a class="el" href="classramses_1_1RamsesRenderer.html#a6307f22a698040fc1f68f771a39ff253" title="Submits renderer commands (API calls on this instance of RamsesRenderer) since previous flush to be e...">RamsesRenderer::flush</a> is called, they are then executed asynchronously in the renderer core, the order of execution is preserved. Most of the commands have a corresponding callback which reports the result back to the caller via <a class="el" href="classramses_1_1RamsesRenderer.html#a7aeedaa36dd7cc51bbf657298b2a0419" title="Most RamsesRenderer methods push commands to an internal queue which is submitted when calling Ramses...">RamsesRenderer::dispatchEvents</a>. Some commands can fail immediately by returning a status with value other than StatusOK, in such case there will be no callback, because the command will not even be submitted. <a class="el" href="classramses_1_1RamsesRenderer.html" title="RamsesRenderer is the main renderer component which provides API to configure and control the way con...">RamsesRenderer</a> API is not thread-safe. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ramses-example-local-client-dcsm_2src_2main_8cpp-example.html#_a102">ramses-example-local-client-dcsm/src/main.cpp</a>, <a class="el" href="ramses-example-local-client_2src_2main_8cpp-example.html#_a11">ramses-example-local-client/src/main.cpp</a>, <a class="el" href="ramses-example-local-datalink_2src_2main_8cpp-example.html#_a9">ramses-example-local-datalink/src/main.cpp</a>, <a class="el" href="ramses-example-local-displays_2src_2main_8cpp-example.html#_a75">ramses-example-local-displays/src/main.cpp</a>, <a class="el" href="ramses-example-local-dma-offscreenbuffer_2src_2main_8cpp-example.html#_a9">ramses-example-local-dma-offscreenbuffer/src/main.cpp</a>, <a class="el" href="ramses-example-local-geometry-shaders_2src_2main_8cpp-example.html#_a11">ramses-example-local-geometry-shaders/src/main.cpp</a>, <a class="el" href="ramses-example-local-offscreenbuffer_2src_2main_8cpp-example.html#_a4">ramses-example-local-offscreenbuffer/src/main.cpp</a>, <a class="el" href="ramses-example-local-pick-handling_2src_2main_8cpp-example.html#_a25">ramses-example-local-pick-handling/src/main.cpp</a>, <a class="el" href="ramses-example-local-scene-referencing_2src_2main_8cpp-example.html#_a76">ramses-example-local-scene-referencing/src/main.cpp</a>, and <a class="el" href="ramses-example-local-viewport-link_2src_2main_8cpp-example.html#_a9">ramses-example-local-viewport-link/src/main.cpp</a>.</dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a40fec1c0331111e1f1a24f946bd961c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40fec1c0331111e1f1a24f946bd961c3">&#9670;&nbsp;</a></span>RamsesRenderer() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ramses::RamsesRenderer::RamsesRenderer </td>
          <td>(</td>
          <td class="paramtype">RamsesRendererImpl &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor of <a class="el" href="classramses_1_1RamsesRenderer.html" title="RamsesRenderer is the main renderer component which provides API to configure and control the way con...">RamsesRenderer</a>. </p>

</div>
</div>
<a id="a987acea6b24d68446f4ba40300c15183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a987acea6b24d68446f4ba40300c15183">&#9670;&nbsp;</a></span>RamsesRenderer() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ramses::RamsesRenderer::RamsesRenderer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted default constructor. </p>

</div>
</div>
<a id="a838a0662f0754430fc64d6791ddb8c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838a0662f0754430fc64d6791ddb8c7b">&#9670;&nbsp;</a></span>RamsesRenderer() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ramses::RamsesRenderer::RamsesRenderer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classramses_1_1RamsesRenderer.html">RamsesRenderer</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>unused </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3c18812bd5b480e6373cc9c1949564ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c18812bd5b480e6373cc9c1949564ca">&#9670;&nbsp;</a></span>createDcsmContentControl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classramses_1_1DcsmContentControl.html">DcsmContentControl</a>* ramses::RamsesRenderer::createDcsmContentControl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <a class="el" href="classramses_1_1DcsmContentControl.html" title="DcsmContentControl provides way to interact with both Dcsm (as consumer) and renderer content control...">ramses::DcsmContentControl</a> to control content states. </p>
<p><a class="el" href="classramses_1_1DcsmContentControl.html" title="DcsmContentControl provides way to interact with both Dcsm (as consumer) and renderer content control...">ramses::DcsmContentControl</a> can be used to control content states (a DCSM content is an abstraction for a scene). In addition <a class="el" href="classramses_1_1DcsmContentControl.html" title="DcsmContentControl provides way to interact with both Dcsm (as consumer) and renderer content control...">ramses::DcsmContentControl</a> handles content states in the DCSM protocol context, it is essentially a combination of renderer scene control API and <a class="el" href="classramses_1_1DcsmConsumer.html" title="Class representing DCSM consumer side.">ramses::DcsmConsumer</a>. There can be only a single instance of <a class="el" href="classramses_1_1DcsmContentControl.html" title="DcsmContentControl provides way to interact with both Dcsm (as consumer) and renderer content control...">ramses::DcsmContentControl</a> within <a class="el" href="classramses_1_1RamsesRenderer.html#a40fec1c0331111e1f1a24f946bd961c3" title="Constructor of RamsesRenderer.">RamsesRenderer</a>. Calling this method more than once will fail. This method will return nullptr in case an internal policy disallows controlling of scenes through this API - this could mean that there is another, incompatible scene control mechanism in use. <a class="el" href="classramses_1_1DcsmContentControl.html" title="DcsmContentControl provides way to interact with both Dcsm (as consumer) and renderer content control...">ramses::DcsmContentControl</a> has its own event dispatching mechanism, see <a class="el" href="classramses_1_1DcsmContentControl.html" title="DcsmContentControl provides way to interact with both Dcsm (as consumer) and renderer content control...">ramses::DcsmContentControl</a> for details.</p>
<p>Obtaining the <a class="el" href="classramses_1_1DcsmContentControl.html" title="DcsmContentControl provides way to interact with both Dcsm (as consumer) and renderer content control...">ramses::DcsmContentControl</a> will disallow usage of different type of scene control (<a class="el" href="classramses_1_1RendererSceneControl.html" title="Control states of scenes.">ramses::RendererSceneControl</a>). <a class="el" href="classramses_1_1RamsesRenderer.html#a40fec1c0331111e1f1a24f946bd961c3" title="Constructor of RamsesRenderer.">RamsesRenderer</a> is owner of the <a class="el" href="classramses_1_1DcsmContentControl.html" title="DcsmContentControl provides way to interact with both Dcsm (as consumer) and renderer content control...">ramses::DcsmContentControl</a> API and the pointer stays valid as long as this <a class="el" href="classramses_1_1RamsesRenderer.html#a40fec1c0331111e1f1a24f946bd961c3" title="Constructor of RamsesRenderer.">RamsesRenderer</a> instance is alive. It cannot be destroyed without destroying the <a class="el" href="classramses_1_1RamsesRenderer.html#a40fec1c0331111e1f1a24f946bd961c3" title="Constructor of RamsesRenderer.">RamsesRenderer</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <a class="el" href="classramses_1_1DcsmContentControl.html" title="DcsmContentControl provides way to interact with both Dcsm (as consumer) and renderer content control...">ramses::DcsmContentControl</a>, or nullptr on error </dd></dl>

</div>
</div>
<a id="a5e8715c650b5617440220f6980f8cfbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e8715c650b5617440220f6980f8cfbe">&#9670;&nbsp;</a></span>createDisplay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a> ramses::RamsesRenderer::createDisplay </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classramses_1_1DisplayConfig.html">DisplayConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a display based on provided display config. Creation of a display is an asynchronous action and the display will be created during the next render loop. The result of the createDisplay can be retrieved via dispatchEvents which will trigger a callback after the asynchronous action was processed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The display config to create and configure the new display. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Display id that can be used to refer to the created display. <a class="el" href="classramses_1_1StronglyTypedValue.html#af3fe119eff10ba4ef87f1fe6ab02f4f4" title="Static Getter for Invalid.">displayId_t::Invalid()</a> in case of error. Display creation can still fail even if a valid display id is returned, the result of the actual creation can be retrieved via dispatchEvents. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ramses-example-local-dma-offscreenbuffer_2src_2main_8cpp-example.html#a100">ramses-example-local-dma-offscreenbuffer/src/main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aa2325f5f74258cf4bd68b54b5403aae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2325f5f74258cf4bd68b54b5403aae0">&#9670;&nbsp;</a></span>createDmaOffscreenBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a> ramses::RamsesRenderer::createDmaOffscreenBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a>&#160;</td>
          <td class="paramname"><em>display</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bufferFourccFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>usageFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>modifier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Additional API to create an offscreen buffer using DMA buffer for internal storage. (see <a class="el" href="classramses_1_1RamsesRenderer.html#addc19bf22f0c5fd8e4559e544703ac9a" title="Will create an offscreen buffer that can be used to render scenes into (see ramses::RendererSceneCont...">createOffscreenBuffer</a>) </p>
<p>The created offscreen buffer uses a DMA buffer based on a GBM buffer object for its internal storage, which can be mapped to CPU memory, instead of standard OpenGL textures and render storages. The created offscreen buffer can be rendered into and linked to texture consumers, like other offscreen buffer types. This type of offscreen buffers can be created only if the platform provides the necessary support, and if the render node for creation of GBM device is provided on <a class="el" href="classramses_1_1DisplayConfig.html#a2fdd1941110449823b85e4c779371021" title="Set the render node to use for creating GBM buffer objects used for creating DMA Offscreen buffers on...">ramses::DisplayConfig::setPlatformRenderNode</a>.</p>
<p>DMA offscreen buffer can only have a color component, no depth or stencil.</p>
<p>Notes: It is of particular importance to avoid CPU operations on the mapped memory while GPU could be accessing the offscreen buffer's memory for executing asynchronous rendering commands.</p><ul>
<li>If a DMA offscreen buffer is being used by the GPU for rendering operations, it is the responsibility of the user not to attempt accessing the CPU mapped memory for that buffer.</li>
<li>Due to the asynchronous nature of OpenGL and render pipeline execution, an offscreen buffer can still be in use after the call to <a class="el" href="classramses_1_1RamsesRenderer.html#a8bceaf9ed2fd659a05d2b12645a6bfdd" title="Prepare content to be rendered in next frame and render next frame.">doOneLoop</a> is finished. It is important to submit the commands to get the offscreen buffer out of the rendering pipeline, then make at least two calls to <a class="el" href="classramses_1_1RamsesRenderer.html#a8bceaf9ed2fd659a05d2b12645a6bfdd" title="Prepare content to be rendered in next frame and render next frame.">doOneLoop</a> (in case of double buffering) before accessing the CPU mapped memory for that buffer</li>
<li>An offscreen buffer is a part of the rendering pipeline as long as it is either being used as input, i.e., by linking to a texture consumer via <a class="el" href="classramses_1_1RendererSceneControl.html#a404275629b0b73ad04d10f4a1649e8ba" title="Links display&#39;s offscreen buffer to a data consumer in scene.">ramses::RendererSceneControl::linkOffscreenBuffer</a>, or being used for output by rendering some scenes into it via <a class="el" href="classramses_1_1RendererSceneControl.html#a865b4e80546bf49191ec6307f0c39b17" title="Set scene display buffer assignment.">ramses::RendererSceneControl::setSceneDisplayBufferAssignment</a></li>
</ul>
<p>It is only possible to create DMA offscreen buffers if renderer is running using <a class="el" href="classramses_1_1RamsesRenderer.html#a8bceaf9ed2fd659a05d2b12645a6bfdd" title="Prepare content to be rendered in next frame and render next frame.">doOneLoop</a>. Calling this method on a renderer with display threads will fail right away with error status without invoking a callback <a class="el" href="classramses_1_1IRendererEventHandler.html#a906e3abfe2d37f1a113f9edb9dac3fce" title="This method will be called after an offscreen buffer is created (or failed to be created) as a result...">ramses::IRendererEventHandler::offscreenBufferCreated</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">display</td><td>Id of display for which the buffer should be created </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>Width of the buffer to be created (has to be higher than 0 and lower than 4096) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>Height of the buffer to be created (has to be higher than 0 and lower than 4096) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferFourccFormat</td><td>Format to be used for underlying storage of the buffer, as specified in drm_fourcc.h on the target platform </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">usageFlags</td><td>Usage flags used for creation of the underlying GBM buffer object, as specific in enum gbm_bo_flags on the target platform </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">modifier</td><td>Optional format modifier. If not needed set to DRM_FORMAT_MOD_INVALID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Identifier of the created offscreen buffer. In case of unsupported resolution or renderer running in own thread <code><a class="el" href="classramses_1_1StronglyTypedValue.html#af3fe119eff10ba4ef87f1fe6ab02f4f4" title="Static Getter for Invalid.">displayBufferId_t::Invalid()</a></code> will be returned with no renderer event generated. Note that the buffer will be created asynchronously and there will be a renderer event once the operation is finished. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ramses-example-local-dma-offscreenbuffer_2src_2main_8cpp-example.html#a86">ramses-example-local-dma-offscreenbuffer/src/main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aba3e4d6c6573f9333034bc2d711101b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba3e4d6c6573f9333034bc2d711101b0">&#9670;&nbsp;</a></span>createInterruptibleOffscreenBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a> ramses::RamsesRenderer::createInterruptibleOffscreenBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a>&#160;</td>
          <td class="paramname"><em>display</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Additional API to create an offscreen buffer as interruptible. (see <a class="el" href="classramses_1_1RamsesRenderer.html#addc19bf22f0c5fd8e4559e544703ac9a" title="Will create an offscreen buffer that can be used to render scenes into (see ramses::RendererSceneCont...">createOffscreenBuffer</a>) </p>
<p>This allows the renderer to interrupt rendering of scenes to such offscreen buffer if the time budget for rendering is exceeded within a frame (see <a class="el" href="classramses_1_1RamsesRenderer.html#ac371e5e8e6a581a8d16f39e9ece1ed99" title="Sets time limits for time-out of different sections of render and update loop.">setFrameTimerLimits</a>). The rendering continues next frame starting from the interruption point.</p>
<p>The renderer creates two render targets on GPU (front and back) for every interruptible offscreen buffer. It then renders into the back render target of the offscreen buffer, while it is possible to read the content of front render target with content from previous frame (or older if interrupted for several frames).</p>
<p>Note that whenever a scene gets assigned to interruptible offscreen buffer, it is not guaranteed anymore that it will be fully rendered every frame. Essentially it is rendered with lower priority.</p>
<p>The created offscreen buffer always has color, depth and stencil buffers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">display</td><td>Id of display for which the buffer should be created </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>Width of the buffer to be created (has to be higher than 0 and lower than 4096) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>Height of the buffer to be created (has to be higher than 0 and lower than 4096) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Identifier of the created offscreen buffer. In case of unsupported resolution <code><a class="el" href="classramses_1_1StronglyTypedValue.html#af3fe119eff10ba4ef87f1fe6ab02f4f4" title="Static Getter for Invalid.">displayBufferId_t::Invalid()</a></code> will be returned with no renderer event generated. Note that the buffer will be created asynchronously and there will be a renderer event once the operation is finished. </dd></dl>

</div>
</div>
<a id="adf9eb8aa6d3aaa227250256556004ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf9eb8aa6d3aaa227250256556004ac1">&#9670;&nbsp;</a></span>createInterruptibleOffscreenBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a> ramses::RamsesRenderer::createInterruptibleOffscreenBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classramses_1_1RamsesRenderer.html">RamsesRenderer</a> &amp;&#160;</td>
          <td class="paramname"><em>renderer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a>&#160;</td>
          <td class="paramname"><em>display</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2778df9cdbae5cb361850633bfde5895">EDepthBufferType</a>&#160;</td>
          <td class="paramname"><em>depthBufferType</em> = <code><a class="el" href="namespaceramses.html#a2778df9cdbae5cb361850633bfde5895aed4959723f8a2a25152521451635dcf1">EDepthBufferType_DepthStencil</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Additional API to create an offscreen buffer as interruptible. This allows the renderer to interrupt rendering of scenes to such offscreen buffer if the time budget for rendering is exceeded within a frame (see <a class="el" href="classramses_1_1RamsesRenderer.html#ac371e5e8e6a581a8d16f39e9ece1ed99" title="Sets time limits for time-out of different sections of render and update loop.">setFrameTimerLimits</a>). The rendering continues next frame starting from the interruption point. </p>
<p>The renderer creates two render targets on GPU (front and back) for every interruptible offscreen buffer. It then renders into the back render target of the offscreen buffer, while it is possible to read the content of front render target with content from previous frame (or older if interrupted for several frames).</p>
<p>Note that whenever a scene gets assigned to interruptible offscreen buffer, it is not guaranteed anymore that it will be fully rendered every frame. Essentially it is rendered with lower priority.</p>
<p>The created offscreen buffer always has a color buffer, but depth and stencil buffers can be configured.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">renderer</td><td>The renderer to call this method on. This API is temporarily added in static fashion for ABI compatibility. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">display</td><td>Id of display for which the buffer should be created </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>Width of the buffer to be created (has to be higher than 0 and lower than 4096) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>Height of the buffer to be created (has to be higher than 0 and lower than 4096) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depthBufferType</td><td>Optional setting to configure depth and stencil buffers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Identifier of the created offscreen buffer. In case of unsupported resolution <code><a class="el" href="classramses_1_1StronglyTypedValue.html#af3fe119eff10ba4ef87f1fe6ab02f4f4" title="Static Getter for Invalid.">displayBufferId_t::Invalid()</a></code> will be returned with no renderer event generated. Note that the buffer will be created asynchronously and there will be a renderer event once the operation is finished. </dd></dl>

</div>
</div>
<a id="addc19bf22f0c5fd8e4559e544703ac9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addc19bf22f0c5fd8e4559e544703ac9a">&#9670;&nbsp;</a></span>createOffscreenBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a> ramses::RamsesRenderer::createOffscreenBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a>&#160;</td>
          <td class="paramname"><em>display</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sampleCount</em> = <code>0u</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Will create an offscreen buffer that can be used to render scenes into (see <a class="el" href="classramses_1_1RendererSceneControl.html#a865b4e80546bf49191ec6307f0c39b17" title="Set scene display buffer assignment.">ramses::RendererSceneControl::setSceneDisplayBufferAssignment</a>) and can be linked as input to a consumer texture sampler (see <a class="el" href="classramses_1_1RendererSceneControl.html#a404275629b0b73ad04d10f4a1649e8ba" title="Links display&#39;s offscreen buffer to a data consumer in scene.">ramses::RendererSceneControl::linkOffscreenBuffer</a>). </p>
<p>The created offscreen buffer always has color, depth and stencil buffer attached. A multisampled buffer will be created if sampleCount greater than 0, note that the value is just a hint for the device, the actual number of samples might be different depending on device driver implementation. If the number of samples exceeds device capabilities the number of samples it will be clamped to its maximum supported (creation will succeeded with a warning log).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">display</td><td>id of display for which the buffer should be created </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>width of the buffer to be created (has to be higher than 0 and lower than 4096) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>height of the buffer to be created (has to be higher than 0 and lower than 4096) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sampleCount</td><td>Optional sample count for MSAA. Default value is 0 for no MSAA. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Identifier of the created offscreen buffer. In case of unsupported resolution <code><a class="el" href="classramses_1_1StronglyTypedValue.html#af3fe119eff10ba4ef87f1fe6ab02f4f4" title="Static Getter for Invalid.">displayBufferId_t::Invalid()</a></code> will be returned with no renderer event generated. Note that the buffer will be created asynchronously and there will be a renderer event once the operation is finished. </dd></dl>

</div>
</div>
<a id="a471dd6ede67fd75a504ea6b412082a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a471dd6ede67fd75a504ea6b412082a64">&#9670;&nbsp;</a></span>createOffscreenBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a> ramses::RamsesRenderer::createOffscreenBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classramses_1_1RamsesRenderer.html">RamsesRenderer</a> &amp;&#160;</td>
          <td class="paramname"><em>renderer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a>&#160;</td>
          <td class="paramname"><em>display</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sampleCount</em> = <code>0u</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2778df9cdbae5cb361850633bfde5895">EDepthBufferType</a>&#160;</td>
          <td class="paramname"><em>depthBufferType</em> = <code><a class="el" href="namespaceramses.html#a2778df9cdbae5cb361850633bfde5895aed4959723f8a2a25152521451635dcf1">EDepthBufferType_DepthStencil</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Will create an offscreen buffer that can be used to render scenes into (see <a class="el" href="classramses_1_1RendererSceneControl.html#a865b4e80546bf49191ec6307f0c39b17" title="Set scene display buffer assignment.">ramses::RendererSceneControl::setSceneDisplayBufferAssignment</a>) and can be linked as input to a consumer texture sampler (see <a class="el" href="classramses_1_1RendererSceneControl.html#a404275629b0b73ad04d10f4a1649e8ba" title="Links display&#39;s offscreen buffer to a data consumer in scene.">ramses::RendererSceneControl::linkOffscreenBuffer</a>). </p>
<p>The created offscreen buffer always has a color buffer, but depth and stencil buffers can be configured.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">renderer</td><td>The renderer to call this method on. This API is temporarily added in static fashion for ABI compatibility. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">display</td><td>id of display for which the buffer should be created </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>width of the buffer to be created (has to be higher than 0 and lower than 4096) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>height of the buffer to be created (has to be higher than 0 and lower than 4096) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sampleCount</td><td>Optional sample count for MSAA number of samples. Default value is Zero, which disables MSAA for the offscreen buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depthBufferType</td><td>Optional setting to configure depth and stencil buffers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Identifier of the created offscreen buffer. In case of unsupported resolution <code><a class="el" href="classramses_1_1StronglyTypedValue.html#af3fe119eff10ba4ef87f1fe6ab02f4f4" title="Static Getter for Invalid.">displayBufferId_t::Invalid()</a></code> will be returned with no renderer event generated. Note that the buffer will be created asynchronously and there will be a renderer event once the operation is finished. </dd></dl>

</div>
</div>
<a id="ac1d683d3ec9bdfae4e63a27d99f9bf9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1d683d3ec9bdfae4e63a27d99f9bf9e">&#9670;&nbsp;</a></span>destroyDisplay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::destroyDisplay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a>&#160;</td>
          <td class="paramname"><em>displayId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a display. Destruction of a display is an asynchronous action and the actual display components (window, device, etc.) will be released during the next render loop. The result of the destroyDisplay can be retrieved via dispatchEvents which will trigger a callback with the result after the asynchronous action was processed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">displayId</td><td>The display id of the display to destroy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function.">getStatusMessage()</a>. </dd></dl>

</div>
</div>
<a id="a92e4ab2cf1d3c87290c4eeac5cd207e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e4ab2cf1d3c87290c4eeac5cd207e8">&#9670;&nbsp;</a></span>destroyOffscreenBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::destroyOffscreenBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a>&#160;</td>
          <td class="paramname"><em>display</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a>&#160;</td>
          <td class="paramname"><em>offscreenBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Will destroy a previously created offscreen buffer. If there are any consumer texture samplers linked to this buffer, these links will be removed. Offscreen buffer will fail to be destroyed if there are any scenes assigned to it, these scenes have to be first assigned to another buffer or framebuffer or unmapped from display. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">display</td><td>id of display which the buffer belongs to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offscreenBuffer</td><td>id of buffer to destroy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function.">getStatusMessage()</a>. </dd></dl>

</div>
</div>
<a id="a7aeedaa36dd7cc51bbf657298b2a0419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aeedaa36dd7cc51bbf657298b2a0419">&#9670;&nbsp;</a></span>dispatchEvents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::dispatchEvents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classramses_1_1IRendererEventHandler.html">IRendererEventHandler</a> &amp;&#160;</td>
          <td class="paramname"><em>rendererEventHandler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Most <a class="el" href="classramses_1_1RamsesRenderer.html" title="RamsesRenderer is the main renderer component which provides API to configure and control the way con...">RamsesRenderer</a> methods push commands to an internal queue which is submitted when calling <a class="el" href="classramses_1_1RamsesRenderer.html#a6307f22a698040fc1f68f771a39ff253" title="Submits renderer commands (API calls on this instance of RamsesRenderer) since previous flush to be e...">RamsesRenderer::flush</a>. The commands are then executed during a render loop (<a class="el" href="classramses_1_1RamsesRenderer.html#a8bceaf9ed2fd659a05d2b12645a6bfdd" title="Prepare content to be rendered in next frame and render next frame.">RamsesRenderer::doOneLoop</a> or in a render thread if used <a class="el" href="classramses_1_1RamsesRenderer.html#a90489cf440602591c90f7a08bb5958ab" title="Starts update and render loop in threaded mode.">RamsesRenderer::startThread</a>). Some of these calls result in an event (can be both informational and data). Such events and their result can be retrieved using the dispatchEvents call. <em>IMPORTANT</em> Renderer events must be regularly consumed by calling <a class="el" href="classramses_1_1RamsesRenderer.html#a7aeedaa36dd7cc51bbf657298b2a0419" title="Most RamsesRenderer methods push commands to an internal queue which is submitted when calling Ramses...">dispatchEvents()</a> in order to prevent buffer overflow of the internal event queue, even if the application is not interested in those events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rendererEventHandler</td><td>User class that implements the callbacks that can be triggered if a corresponding event happened. Check <a class="el" href="classramses_1_1IRendererEventHandler.html" title="Provides an interface for handling the result of renderer events. Implementation of this interface mu...">ramses::IRendererEventHandler</a> documentation for more details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function.">getStatusMessage()</a>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ramses-example-local-dma-offscreenbuffer_2src_2main_8cpp-example.html#a19">ramses-example-local-dma-offscreenbuffer/src/main.cpp</a>, and <a class="el" href="ramses-example-local-offscreenbuffer_2src_2main_8cpp-example.html#a13">ramses-example-local-offscreenbuffer/src/main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a8bceaf9ed2fd659a05d2b12645a6bfdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bceaf9ed2fd659a05d2b12645a6bfdd">&#9670;&nbsp;</a></span>doOneLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::doOneLoop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare content to be rendered in next frame and render next frame. </p>
<p>Update and render of all displays is executed sequentially in caller's thread. For active rendering it is recommended to use threaded mode instead (<a class="el" href="classramses_1_1RamsesRenderer.html#a90489cf440602591c90f7a08bb5958ab" title="Starts update and render loop in threaded mode.">startThread</a>). Once this method is called a threaded mode cannot be used anymore.</p>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function.">getStatusMessage()</a>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ramses-example-local-datalink_2src_2main_8cpp-example.html#a14">ramses-example-local-datalink/src/main.cpp</a>, <a class="el" href="ramses-example-local-dma-offscreenbuffer_2src_2main_8cpp-example.html#a18">ramses-example-local-dma-offscreenbuffer/src/main.cpp</a>, and <a class="el" href="ramses-example-local-viewport-link_2src_2main_8cpp-example.html#a12">ramses-example-local-viewport-link/src/main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a6307f22a698040fc1f68f771a39ff253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6307f22a698040fc1f68f771a39ff253">&#9670;&nbsp;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits renderer commands (API calls on this instance of <a class="el" href="classramses_1_1RamsesRenderer.html" title="RamsesRenderer is the main renderer component which provides API to configure and control the way con...">RamsesRenderer</a>) since previous flush to be executed in the next renderer update loop. </p>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function.">getStatusMessage()</a>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ramses-example-local-dma-offscreenbuffer_2src_2main_8cpp-example.html#a101">ramses-example-local-dma-offscreenbuffer/src/main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="addff71feff4e101e665631b6b27363a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addff71feff4e101e665631b6b27363a6">&#9670;&nbsp;</a></span>getDisplayFramebuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a> ramses::RamsesRenderer::getDisplayFramebuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a>&#160;</td>
          <td class="paramname"><em>displayId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get display's framebuffer ID. Every display upon creation has one framebuffer which can be referenced by a display buffer ID to be used in various API methods that work with either a framebuffer or an offscreen buffer (e.g. RamsesRenderer::setBufferClearColor). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">displayId</td><td>The ID of display for which the framebuffer ID is being queried. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Display's framebuffer ID or invalid ID if display does not exist. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ramses-example-local-dma-offscreenbuffer_2src_2main_8cpp-example.html#a110">ramses-example-local-dma-offscreenbuffer/src/main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aab3f7a514085d2e6643d841bbb69b41d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab3f7a514085d2e6643d841bbb69b41d">&#9670;&nbsp;</a></span>getDmaOffscreenBufferFDAndStride()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::getDmaOffscreenBufferFDAndStride </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a>&#160;</td>
          <td class="paramname"><em>display</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a>&#160;</td>
          <td class="paramname"><em>displayBufferId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the FD and stride for a DMA offscreen buffer previously created on the given display. </p>
<p>Get the file descriptor and stride for the underlying GBM buffer object used for a DMA offscreenbuffer that was created using <a class="el" href="classramses_1_1RamsesRenderer.html#aa2325f5f74258cf4bd68b54b5403aae0" title="Additional API to create an offscreen buffer using DMA buffer for internal storage....">ramses::RamsesRenderer::createDmaOffscreenBuffer</a>. This function can be safely called only after a successful offscreen buffer event is disptched (using <a class="el" href="classramses_1_1IRendererEventHandler.html#a906e3abfe2d37f1a113f9edb9dac3fce" title="This method will be called after an offscreen buffer is created (or failed to be created) as a result...">ramses::IRendererEventHandler::offscreenBufferCreated</a>) for the meant offscreen buffer.</p>
<p>The file descriptor could be used for mapping the underlying memory used by the offscreen buffer to CPU. As long the mapped memory is in use it is important to watch the mentioned considerations in <a class="el" href="classramses_1_1RamsesRenderer.html#aa2325f5f74258cf4bd68b54b5403aae0" title="Additional API to create an offscreen buffer using DMA buffer for internal storage....">createDmaOffscreenBuffer</a>. It is the responsibility of the user to unmap that memory on offscreen buffer destruction or when the CPU operations do not need to be applied to that memory any more.</p>
<p>Stride could be used for calculating addresses of specific pixels within mapped memory, where the data for each row in the image starts at a multiple of stride. Buffer stride can be different from the calculatable row size in bytes relying only on buffer width and format pixel size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">display</td><td>Id of display for which the buffer was created </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">displayBufferId</td><td>Id of the DMA offscreen buffer for which the FD should be returned </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fd</td><td>File descriptor of underlying GBM buffer object for DMA offscreen buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stride</td><td>Stride of DMA offsceen buffer in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function.">getStatusMessage()</a>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ramses-example-local-dma-offscreenbuffer_2src_2main_8cpp-example.html#a88">ramses-example-local-dma-offscreenbuffer/src/main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af865674d0f4270c9e846a6f1b8ad2053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af865674d0f4270c9e846a6f1b8ad2053">&#9670;&nbsp;</a></span>getLoopMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#adcfa3b1b4a623dea062782aefa84e002">ELoopMode</a> ramses::RamsesRenderer::getLoopMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current value for loop mode set using <a class="el" href="classramses_1_1RamsesRenderer.html#a2203f9f2e6a6ab233809e1ee85367d89" title="Sets the mode of operation for render loop.">setLoopMode</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The loop mode </dd></dl>

</div>
</div>
<a id="ac8d5685d38fb82c58e13f9274ce087d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8d5685d38fb82c58e13f9274ce087d5">&#9670;&nbsp;</a></span>getMaximumFramerate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float ramses::RamsesRenderer::getMaximumFramerate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current value for maximum frame rate per second currently set (<a class="el" href="classramses_1_1RamsesRenderer.html#a96181331eab7ab60dd607a3bcab999a6" title="Sets the maximum frame rate per second for the update/render loop when in threaded mode.">setMaximumFramerate</a>). </p>
<dl class="section return"><dt>Returns</dt><dd>Maximum frame rate per second </dd></dl>

</div>
</div>
<a id="aca664b15215a8cb1f410db4da3c65296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca664b15215a8cb1f410db4da3c65296">&#9670;&nbsp;</a></span>getSceneControlAPI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classramses_1_1RendererSceneControl.html">RendererSceneControl</a>* ramses::RamsesRenderer::getSceneControlAPI </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get scene control API. </p>
<p>Typical application using Ramses has different components controlling the renderer (display management, frame limits and looping control, etc.) and controlling the states of content to be rendered (show/hide scene, data link, assign to display buffer, etc.). The scene control part can be obtained using this method, calling this method multiple times is allowed and will always return the same pointer, i.e. there is only a single instance per <a class="el" href="classramses_1_1RamsesRenderer.html" title="RamsesRenderer is the main renderer component which provides API to configure and control the way con...">RamsesRenderer</a>. This method will return nullptr in case an internal policy disallows controlling of scenes through this API - this could mean that there is another, incompatible scene control mechanism in use. <a class="el" href="classramses_1_1Scene.html" title="The Scene holds a scene graph. It is the essential class for distributing content to the ramses syste...">Scene</a> control API has its own independent flush and event dispatching, see <a class="el" href="classramses_1_1RendererSceneControl.html" title="Control states of scenes.">ramses::RendererSceneControl</a> for details.</p>
<p>Obtaining the <a class="el" href="classramses_1_1RendererSceneControl.html" title="Control states of scenes.">ramses::RendererSceneControl</a> will disallow usage of different type of scene control (<a class="el" href="classramses_1_1DcsmContentControl.html" title="DcsmContentControl provides way to interact with both Dcsm (as consumer) and renderer content control...">ramses::DcsmContentControl</a>). <a class="el" href="classramses_1_1RamsesRenderer.html#a40fec1c0331111e1f1a24f946bd961c3" title="Constructor of RamsesRenderer.">RamsesRenderer</a> is owner of the <a class="el" href="classramses_1_1RendererSceneControl.html" title="Control states of scenes.">ramses::RendererSceneControl</a> API and the pointer stays valid as long as this <a class="el" href="classramses_1_1RamsesRenderer.html#a40fec1c0331111e1f1a24f946bd961c3" title="Constructor of RamsesRenderer.">RamsesRenderer</a> instance is alive. It cannot be destroyed without destroying the <a class="el" href="classramses_1_1RamsesRenderer.html#a40fec1c0331111e1f1a24f946bd961c3" title="Constructor of RamsesRenderer.">RamsesRenderer</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to scene control API, or nullptr on error </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ramses-example-local-dma-offscreenbuffer_2src_2main_8cpp-example.html#a20">ramses-example-local-dma-offscreenbuffer/src/main.cpp</a>, <a class="el" href="ramses-example-local-offscreenbuffer_2src_2main_8cpp-example.html#a14">ramses-example-local-offscreenbuffer/src/main.cpp</a>, and <a class="el" href="ramses-example-local-viewport-link_2src_2main_8cpp-example.html#a13">ramses-example-local-viewport-link/src/main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a2bd3f2d1e4f5782019544a52edb8bf2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd3f2d1e4f5782019544a52edb8bf2e">&#9670;&nbsp;</a></span>isThreadRunning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ramses::RamsesRenderer::isThreadRunning </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current state of rendering thread(s) running. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if thread is running (started and not stopped), false otherwise. </dd></dl>

</div>
</div>
<a id="a8e1cdc22128187b688f9c236b0109004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e1cdc22128187b688f9c236b0109004">&#9670;&nbsp;</a></span>logRendererInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::logRendererInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints detailed information about renderer state and contents to the log output. </p>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function.">getStatusMessage()</a>. </dd></dl>

</div>
</div>
<a id="ac5a7307221202b2c07a1637be9b84dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5a7307221202b2c07a1637be9b84dde">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classramses_1_1RamsesRenderer.html">RamsesRenderer</a>&amp; ramses::RamsesRenderer::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classramses_1_1RamsesRenderer.html">RamsesRenderer</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted copy assignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>unused </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unused </dd></dl>

</div>
</div>
<a id="a88b8b49e394f9676224f6a55e6413862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88b8b49e394f9676224f6a55e6413862">&#9670;&nbsp;</a></span>readPixels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::readPixels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a>&#160;</td>
          <td class="paramname"><em>displayId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a>&#160;</td>
          <td class="paramname"><em>displayBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Triggers an asynchronous read back of a display buffer memory from GPU to system memory. </p>
<p>The color data from the provided rectangle coordinates will be read back and stored as RGBA8. If the coordinates lie outside the rendered region the result is undefined.</p>
<p>If a read pixels command is issued for a display buffer while a previous read pixels command for the same buffer was not yet executed only the last submitted read pixel command gets executed.</p>
<p>The pixel data can be obtained as a renderer event after the asynchronous read back is finished, see <a class="el" href="classramses_1_1RamsesRenderer.html#a7aeedaa36dd7cc51bbf657298b2a0419" title="Most RamsesRenderer methods push commands to an internal queue which is submitted when calling Ramses...">RamsesRenderer::dispatchEvents</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">displayId</td><td>id of display to read pixels from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">displayBuffer</td><td>Id of display buffer to read pixels from, if <a class="el" href="classramses_1_1StronglyTypedValue.html#af3fe119eff10ba4ef87f1fe6ab02f4f4" title="Static Getter for Invalid.">ramses::displayBufferId_t::Invalid()</a> is passed then pixels are read from the display's framebuffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The starting offset in the original image (i.e. left border) in pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>The starting offset in the original image (i.e. lower border) in pixels. The origin of the image is supposed to be in the lower left corner. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The width of the read image in pixels. Must be greater than Zero. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>The height of the read image in pixels. Must be greater than Zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function.">getStatusMessage()</a>. StatusOK does not guarantee successful read back, the result event has its own status. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ramses-example-local-dma-offscreenbuffer_2src_2main_8cpp-example.html#a109">ramses-example-local-dma-offscreenbuffer/src/main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a615fece250e98bdfde5fae979b55b24e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a615fece250e98bdfde5fae979b55b24e">&#9670;&nbsp;</a></span>setDisplayBufferClearColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::setDisplayBufferClearColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a>&#160;</td>
          <td class="paramname"><em>display</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a>&#160;</td>
          <td class="paramname"><em>displayBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets clear color of a display buffer (display's framebuffer or offscreen buffer). </p>
<p>Clear color is used to clear the whole buffer at the beginning of a rendering cycle (typically every frame). Default clear color is (0, 0, 0, 1). There is no event callback for this operation, the clear color change can be assumed to be effective in the next frame rendered after flushed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">display</td><td>Id of display that the buffer to set clear color belongs to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">displayBuffer</td><td>Id of display buffer to set clear color, if <a class="el" href="classramses_1_1StronglyTypedValue.html#af3fe119eff10ba4ef87f1fe6ab02f4f4" title="Static Getter for Invalid.">ramses::displayBufferId_t::Invalid()</a> is passed then the clear color is set for display's framebuffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>Clear color red channel value [0,1] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>Clear color green channel value [0,1] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Clear color blue channel value [0,1] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Clear color alpha channel value [0,1] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function.">getStatusMessage()</a>. </dd></dl>

</div>
</div>
<a id="ac70f64e98a833178ea7729015fb1e7fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70f64e98a833178ea7729015fb1e7fe">&#9670;&nbsp;</a></span>setDisplayBufferClearFlags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::setDisplayBufferClearFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classramses_1_1RamsesRenderer.html">RamsesRenderer</a> &amp;&#160;</td>
          <td class="paramname"><em>renderer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a>&#160;</td>
          <td class="paramname"><em>display</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a>&#160;</td>
          <td class="paramname"><em>displayBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clearFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets clear flags for a display buffer (display's framebuffer or offscreen buffer). </p>
<p>By default all display buffers' color, depth and stencil are cleared every frame when they are rendered to. This can be overridden for performance or special effect reasons. There is no event callback for this operation, the change can be assumed to be effective in the next frame rendered after flushed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">renderer</td><td>The renderer to call this method on. This API is temporarily added in static fashion for ABI compatibility. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">display</td><td>Id of display that the buffer to set clearing belongs to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">displayBuffer</td><td>Id of display buffer to set clearing, if <a class="el" href="classramses_1_1StronglyTypedValue.html#af3fe119eff10ba4ef87f1fe6ab02f4f4" title="Static Getter for Invalid.">ramses::displayBufferId_t::Invalid()</a> is passed then the clearing is set for display's framebuffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clearFlags</td><td>Bitmask of the <a class="el" href="namespaceramses.html#a5a24b250587d10d14d00389a8a74096a" title="Clear flags used to specify which components of a render target or display buffer should be cleared.">ramses::EClearFlags</a>, use bit OR to select which buffer component to clear or <a class="el" href="namespaceramses.html#a5a24b250587d10d14d00389a8a74096aa556030bb8824a49b1306408794389ea3">ramses::EClearFlags_All</a> to clear all (default). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function.">getStatusMessage()</a>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ramses-example-local-dma-offscreenbuffer_2src_2main_8cpp-example.html#a102">ramses-example-local-dma-offscreenbuffer/src/main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ac371e5e8e6a581a8d16f39e9ece1ed99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac371e5e8e6a581a8d16f39e9ece1ed99">&#9670;&nbsp;</a></span>setFrameTimerLimits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::setFrameTimerLimits </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>limitForSceneResourcesUpload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>limitForClientResourcesUpload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>limitForOffscreenBufferRender</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets time limits for time-out of different sections of render and update loop. </p>
<p>Setting time limits for render/update loop sections instructs the renderer to monitor the amount of time consumed by the sections and interrupt their execution if the set time limit was exceeded. The time limit for every section is calculated since beginning of frame. If a section is interrupted the renderer will execute the sections in the same order in the next frame, but it will continue to execute the interrupted section(s) from the point where it stopped.</p>
<p>Since time limits are calculated relative to the start of the frame, the values set should be monotonically increasing in the order of:</p><ol type="1">
<li>Uploading client resources</li>
<li>Uploading scene resources</li>
<li>Rendering scenes mapped to interruptible offscreen buffers</li>
</ol>
<p>By default sections have infinite time limit, so renderer would not try to interrupt their execution.</p>
<p>!! IMPORTANT !! <a class="el" href="classramses_1_1Scene.html" title="The Scene holds a scene graph. It is the essential class for distributing content to the ramses syste...">Scene</a> resource actions can not be interrupted like other resources. Therefore, if this timer is exceeded, a scene will be force-unsubscribed. Use this timer with caution and merely as a sanity check, NOT as a performance measure! Scenes should not be over-using scene resources, precisely because they can not be interrupted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">limitForSceneResourcesUpload</td><td>Time limit in microseconds (since beginning of frame) for uploading scene resources to GPU </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">limitForClientResourcesUpload</td><td>Time limit in microseconds (since beginning of frame) for uploading client resources to GPU </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">limitForOffscreenBufferRender</td><td>Time limit in microseconds (since beginning of frame) for rendering scenes that are mapped to interruptible offscreen buffers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function.">getStatusMessage()</a>. StatusOK does not guarantee successful read back, the result event has its own status. </dd></dl>

</div>
</div>
<a id="a2b316650d87b61a4dbf4f8c19bd23807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b316650d87b61a4dbf4f8c19bd23807">&#9670;&nbsp;</a></span>setLayerVisibility()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::setLayerVisibility </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>layerId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>visibility</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set visibility of given layer at the system compositor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerId</td><td>id identifying the layer </td></tr>
    <tr><td class="paramname">visibility</td><td>If <code>true</code> the layer's visibility will be enabled, otherwise disabled </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function.">getStatusMessage()</a>. </dd></dl>

</div>
</div>
<a id="a2203f9f2e6a6ab233809e1ee85367d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2203f9f2e6a6ab233809e1ee85367d89">&#9670;&nbsp;</a></span>setLoopMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::setLoopMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#adcfa3b1b4a623dea062782aefa84e002">ELoopMode</a>&#160;</td>
          <td class="paramname"><em>loopMode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the mode of operation for render loop. </p>
<p>Mode can be changed during run-time, in case of threaded mode also while running (no need to <a class="el" href="classramses_1_1RamsesRenderer.html#a01dd58f37a2a782bcb77e25bea81175c" title="Stops thread(s) running the update and render of displays.">stopThread</a>). By default loop mode is set to render and update.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loopMode</td><td>The mode to be used for render loop. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function.">getStatusMessage()</a>. </dd></dl>

</div>
</div>
<a id="a96181331eab7ab60dd607a3bcab999a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96181331eab7ab60dd607a3bcab999a6">&#9670;&nbsp;</a></span>setMaximumFramerate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::setMaximumFramerate </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maximumFramerate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maximum frame rate per second for the update/render loop when in threaded mode. </p>
<p>The parameter is of type float in order to specify any desired frame time (e.g. below 1 FPS). The same maximum frame rate will be applied to all displays. This function can only be used in threaded mode (<a class="el" href="classramses_1_1RamsesRenderer.html#a90489cf440602591c90f7a08bb5958ab" title="Starts update and render loop in threaded mode.">startThread</a>). The default value is 60 FPS. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maximumFramerate</td><td>The maximum frame rate per second to set for the render loop.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function.">getStatusMessage()</a>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ramses-example-local-displays_2src_2main_8cpp-example.html#a80">ramses-example-local-displays/src/main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="acabff95b658cc988622b64517cea5567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acabff95b658cc988622b64517cea5567">&#9670;&nbsp;</a></span>setMaximumFramerate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::setMaximumFramerate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classramses_1_1RamsesRenderer.html">RamsesRenderer</a> &amp;&#160;</td>
          <td class="paramname"><em>renderer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maximumFramerate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a>&#160;</td>
          <td class="paramname"><em>displayId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the maximum frame rate per second for the update/render loop when in threaded mode for given display. </p>
<p>The maximumFramerate parameter is of type float in order to specify any desired frame time (e.g. below 1 FPS). The maximum frame rate will be applied to the display thread responsible for given display id. This function can only be used in threaded mode (<a class="el" href="classramses_1_1RamsesRenderer.html#a90489cf440602591c90f7a08bb5958ab" title="Starts update and render loop in threaded mode.">startThread</a>). The default value is 60 FPS. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderer</td><td>The renderer to apply the value to. This api is added in static fashion for ABI compatibility. </td></tr>
    <tr><td class="paramname">maximumFramerate</td><td>The maximum frame rate per second to set for the render loop. </td></tr>
    <tr><td class="paramname">displayId</td><td>The display id the framerate should be applied to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function.">getStatusMessage()</a>. </dd></dl>

</div>
</div>
<a id="a26564ba54af9e15729e43b86425826bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26564ba54af9e15729e43b86425826bd">&#9670;&nbsp;</a></span>setPendingFlushLimits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::setPendingFlushLimits </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>forceApplyFlushLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>forceUnsubscribeSceneLimit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the number of pending flushes accepted before force-applying them to their scene, or forcefully insubscribing the scene. </p>
<p>RAMSES guarantees that a scene flush is only going to be rendered if all resources (textures, shaders etc.) are received and uploaded to the GPU. This allows a misbehaving client to flood a renderer with flushes which are never executed, causing the renderer to exhaust heap memory. If too many pending flushes are received and queued, they are force-applied to the scene, even if some resources are missing, thus potentially causing flickering. This method allows overriding the number of flushes after a scene is updated to the latest flush and all pending flushes wiped from memory. A low number (e.g. 1) will cause frequent flickering, whereas a high number (e.g. 100000) could cause the renderer to go out of memory. The second parameter (forceUnsubscribeSceneLimit) controls after how many pending flushes a scene is completely unsubscribed. This can be used as a protection against malicious remote scenes. It does not affect local scenes though. It is advisable to set forceUnsubscribeSceneLimit to higher number than forceApplyFlushLimit, because re-subscribing a scene is causing a lot of network traffic and unnecessary memory operations, not to mention the scene is then also not visible until re-subscribed, mapped and shown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">forceApplyFlushLimit</td><td>Number of flushes that can be pending before force applying occurs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forceUnsubscribeSceneLimit</td><td>Number of flushes that can be pending before force un-subscribe occurs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function.">getStatusMessage()</a>. </dd></dl>

</div>
</div>
<a id="a1077a8cd9283f6e313d646459815c931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1077a8cd9283f6e313d646459815c931">&#9670;&nbsp;</a></span>setSkippingOfUnmodifiedBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::setSkippingOfUnmodifiedBuffers </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable skipping of rendering of unmodified buffers. By default the renderer does not re-render buffers (framebuffer or offscreen buffer) if there was no change to any of the content assigned to the buffer. This can save hardware resources or free up resources for rendering of other buffers. It can be however desired to disable such optimization for profiling of worst case scenario or debugging of a graphical glitch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>Enable or disable the feature (enabled initially) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function.">getStatusMessage()</a>. StatusOK does not guarantee successful read back, the result event has its own status. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ramses-example-local-dma-offscreenbuffer_2src_2main_8cpp-example.html#a98">ramses-example-local-dma-offscreenbuffer/src/main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a254d5d21f8685117aeea48cf4a26bde0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a254d5d21f8685117aeea48cf4a26bde0">&#9670;&nbsp;</a></span>setSurfaceOpacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::setSurfaceOpacity </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>surfaceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set opacity of given surface at the system compositor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surfaceId</td><td>id of the surface to set opacity of </td></tr>
    <tr><td class="paramname">opacity</td><td>Opacity in the range 0.0 (fully transparent) to 1.0 (fully opaque) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function.">getStatusMessage()</a>. </dd></dl>

</div>
</div>
<a id="ad9354989524cb902ba736b2e897e5e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9354989524cb902ba736b2e897e5e82">&#9670;&nbsp;</a></span>setSurfaceRectangle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::setSurfaceRectangle </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>surfaceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set output rectangle of given surface at the system compositor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surfaceId</td><td>id of the surface to set the rectangle for </td></tr>
    <tr><td class="paramname">x</td><td>Output position of surface along the x-axis </td></tr>
    <tr><td class="paramname">y</td><td>Output position of surface along the y-axis </td></tr>
    <tr><td class="paramname">width</td><td>Output width of surface </td></tr>
    <tr><td class="paramname">height</td><td>Output height of surface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function.">getStatusMessage()</a>. </dd></dl>

</div>
</div>
<a id="a6732097772becc5818ba94f7aa845a10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6732097772becc5818ba94f7aa845a10">&#9670;&nbsp;</a></span>setSurfaceVisibility()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::setSurfaceVisibility </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>surfaceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>visibility</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set visibility of given surface at the system compositor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surfaceId</td><td>id of the surface to set visibility of </td></tr>
    <tr><td class="paramname">visibility</td><td>visibility to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function.">getStatusMessage()</a>. </dd></dl>

</div>
</div>
<a id="a90489cf440602591c90f7a08bb5958ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90489cf440602591c90f7a08bb5958ab">&#9670;&nbsp;</a></span>startThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::startThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts update and render loop in threaded mode. </p>
<p>Each display will update and render in its own thread. First call to this method enables threaded mode, afterwards it is not possible to call <a class="el" href="classramses_1_1RamsesRenderer.html#a8bceaf9ed2fd659a05d2b12645a6bfdd" title="Prepare content to be rendered in next frame and render next frame.">doOneLoop</a> anymore.</p>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function.">getStatusMessage()</a>. </dd></dl>

</div>
</div>
<a id="a01dd58f37a2a782bcb77e25bea81175c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01dd58f37a2a782bcb77e25bea81175c">&#9670;&nbsp;</a></span>stopThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::stopThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops thread(s) running the update and render of displays. </p>
<p>This function can only be used if startThread was successfully called before. The looping can be restarted by calling <a class="el" href="classramses_1_1RamsesRenderer.html#a90489cf440602591c90f7a08bb5958ab" title="Starts update and render loop in threaded mode.">startThread</a> again.</p>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function.">getStatusMessage()</a>. </dd></dl>

</div>
</div>
<a id="a0e6dd092a73ecf218c36a6dffaddbea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e6dd092a73ecf218c36a6dffaddbea0">&#9670;&nbsp;</a></span>takeSystemCompositorScreenshot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::takeSystemCompositorScreenshot </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>screenIviId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trigger the System Compositor to take a screenshot and store it in a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>File name including path, for storing the screenshot. </td></tr>
    <tr><td class="paramname">screenIviId</td><td>&gt;= 0 to trigger a screenshot on the given IVI screen id, -1 to trigger screenshot on a single existing screen (fails asynchronously if more than one screen exists) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function.">getStatusMessage()</a>. </dd></dl>

</div>
</div>
<a id="a56ef2b5e6b42052bd5ad6c7a61fe78f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56ef2b5e6b42052bd5ad6c7a61fe78f2">&#9670;&nbsp;</a></span>updateWarpingMeshData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceramses.html#a4f09a899b38b8d7bc61f01a2d181ea22">status_t</a> ramses::RamsesRenderer::updateWarpingMeshData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ab30e8bb78242e4d57a4f006f10d1e9dc">displayId_t</a>&#160;</td>
          <td class="paramname"><em>displayId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classramses_1_1WarpingMeshData.html">WarpingMeshData</a> &amp;&#160;</td>
          <td class="paramname"><em>newWarpingMeshData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the warping mesh for the warping postprocessing based on the new config. </p>
<p>Display must be created with warping enabled in order for this operation to succeed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">displayId</td><td>id of display to update. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newWarpingMeshData</td><td>Holds the geometry needed to create the mesh for display warping. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>StatusOK for success, otherwise the returned status can be used to resolve error message using <a class="el" href="classramses_1_1StatusObject.html#a1fbbfea27c8eb369b1f21de42f2e88b1" title="Get the string description for a status provided by a RAMSES API function.">getStatusMessage()</a>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ad73693270161e42d1d5f034d5c74b4db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad73693270161e42d1d5f034d5c74b4db">&#9670;&nbsp;</a></span>RendererFactory</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class RendererFactory</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>RendererFactory is the factory for <a class="el" href="classramses_1_1RamsesRenderer.html" title="RamsesRenderer is the main renderer component which provides API to configure and control the way con...">RamsesRenderer</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a116e218cbff71ef947bdb765a7220559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116e218cbff71ef947bdb765a7220559">&#9670;&nbsp;</a></span>impl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class RamsesRendererImpl&amp; ramses::RamsesRenderer::impl</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores internal data for implementation specifics of <a class="el" href="classramses_1_1RamsesRenderer.html" title="RamsesRenderer is the main renderer component which provides API to configure and control the way con...">RamsesRenderer</a> </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/ramses/ramses/renderer/RendererLib/ramses-renderer-api/include/ramses-renderer-api/<a class="el" href="RamsesRenderer_8h_source.html">RamsesRenderer.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
