<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RAMSES Documentation: RAMSES Content Expiration and Time Limited Validity of Content</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ramses_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RAMSES Documentation
   &#160;<span id="projectnumber">27.0.112</span>
   </div>
   <div id="projectbrief">Information for RAMSES users and developers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">RAMSES Content Expiration and Time Limited Validity of Content </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Latency</h1>
<p>Typically, a rendering application has a loop which directly renders on a screen. The latency in this case between the time where content is prepared until the time the screen shows it is in the range of 1 or 2 frames. However, when showing content with RAMSES, where multiple clients are commiting content possibly over slow network and with performance constraints, the latency can be much larger. Other factors influencing latency can be resource fetching and uploading, blocking due to system compositor.</p>
<h1>Time limited validity of content</h1>
<p>Especially in automotive, there are many cases where validity of content shown on screen is strictly time limited (e.g. obstacles in parking assistant shown too late or too long not corresponding to reality). Latency can be one of the causes of displaying outdated (expired) content but there can be more reasons, for example client not providing up-to-date content frequently enough due to low performance, faulty logic or general failure.</p>
<h1>Expiration time stamps</h1>
<p>RAMSES provides an API allowing the client as content provider to mark every modified state of a scene with a 'expiration date' to inform the renderer that past this point in time that content is not valid anymore. Remember that renderer might be remote and thus not controlled by the client, therefore in the context of RAMSES framework this is one way communication from client to renderer.</p>
<h1>Renderer events</h1>
<p>Renderer receives, processes and displays the content provided by client, therefore only renderer can check the expiration time stamps. It is impossible to define a general rule for reacting on expiration and therefore it is the responsibility of the application logic running the renderer to decide what to do with an expired scene content. RAMSES provides corresponding renderer events for that. First of all there will be an event when a scene uses expiration timestamp for the first time, notifying the application logic on renderer side that expiration monitoring is now active for that scene. An expiration event is then generated when the scene has an expired content, another event will be generated if the scene content recovers from expiration and is up-to-date again. Client can decide to stop monitoring the scene for expiration by setting no expiration timestamp, this will again result in an event on renderer side that the scene is not being monitored anymore.</p>
<h2>Time stamps</h2>
<p>When talking about time and delays, one has to be careful to how the time is measured and how reliable the clock is. In a distributed system, there is also the factor of synchronization of clocks. In order for the check mechanism to work, all system clocks for all participants in the network have to be synchronized</p>
<h2>API</h2>
<p>As mentioned above there is API both on client side and renderer side. Client sets an 'expiration time' (see documentation of <a class="el" href="classramses_1_1Scene.html#a5a4e0fd8b04ce23881f3089bfc4c9556">ramses::Scene::setExpirationTimestamp()</a> for more details) of a scene, this expiration time is commited with the next scene flush together with other changes made to it. What it means is that the flushed state of scene will expire at the set point in time.</p>
<p>The renderer has an asynchroneous event callback which reports when scene is enabled for expiration monitoring (<a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#aa36f55ffddbe50085cb19020d9bc6886" title="This method will be called whenever a scene which was not previously monitored for expiration has req...">ramses::IRendererSceneControlEventHandler::sceneExpirationMonitoringEnabled</a>), when the scene's expiration time is passed (<a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#a994131648d8494923fd77c31a106c4c0" title="This method will be called if a scene which is enabled for expiration monitoring (sceneExpirationMoni...">ramses::IRendererSceneControlEventHandler::sceneExpired</a>), when it catches up and recovers from expiration (<a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#a24f748b279d85ac3e0d0dc11740614a3" title="This method will be called if a scene which previously expired (ramses::Scene::setExpirationTimestamp...">ramses::IRendererSceneControlEventHandler::sceneRecoveredFromExpiration</a>) and when scene disables monitoring by setting expiration timestamp to zero (<a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#a2f9d3c748dc4a553bdcf32b3e7662e73" title="This method will be called whenever a scene which was previously monitored for expiration has request...">ramses::IRendererSceneControlEventHandler::sceneExpirationMonitoringDisabled</a>).</p>
<h2>Example</h2>
<p>A simple example how to use the latency/expiration API of RAMSES is to define a fixed threshold (e.g. 0.5 second), and add this threshold to the expiration timestamp assigned to each scene. Then, whenever a renderer reports that a scene expired, the renderer control logic can temporarily hide the scene and show a fallback scene, e.g. a loading wheel or just a black image. As soon as the original scene recovered, it can be shown again. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
